#!/usr/bin/env python3.9
"""
Company:     NetCracker 
Author:      Core PaaS Group
Version:     0.7
Date:        2021-11-19
Description: Client util to communicate with site-manager in kubernetes based clusters
@todo[3]
    split current single source into modules,classes ; share common code with sm
    make smclient delivery as single binary, using pyinstaller ???
    cli json output
    SM specific data structures : sm_dict; service response: 50%
"""

import argparse
import logging
import threading

from prettytable import PrettyTable

from sm_client.initialization import sm_get_cluster_state, init_and_check_config
from sm_client.prepare import make_ordered_services_to_process
from sm_client.processing import sm_process_service, thread_pool, process_module_services
from sm_client.data.structures import *
from sm_client.validation import validate_operation

MAIN_HELP_SECTION = """
Script to manage DR cases in kubernetes Active-Standby scheme

How to use commands:

  +------------------------------+        +------------------------------+
  |      INITIAL CONDITION       |        |        FINAL CONDITION       |
  +--------------+---------------+--------+--------------+---------------+-----+---------+
  | ACTIVE SITE  | STANDBY SITE  |  ===>  | ACTIVE SITE  | STANDBY SITE  |     | COMMAND |
  +--------------+---------------+  ===>  +--------------+---------------+     +---------+
  | ACTIVE       | STANDBY       |  ===>  | STANDBY      | ACTIVE        |  =  | move    |
  | failed       | STANDBY       |  ===>  | stopped      | ACTIVE        |  =  | stop    |
  | stopped      | ACTIVE        |  ===>  | STANDBY      | ACTIVE        |  =  | return  |
  | ACTIVE       | stopped       |  ===>  | ACTIVE       | STANDBY       |  =  | return  |
  | ACTIVE       | STANDBY       |  ===>  | ACTIVE       | stopped       |  =  | disable |
  +--------------+---------------+--------+--------------+---------------+-----+---------+
"""
SITE_HELP_SECTION = """define the cluster name.
This site:
  will be active in case of move 
  will be standby in case of stop
  will be standby in case of return
  will be disable to maintenance in case of disable
"""

args: argparse.Namespace


def print_service_order(ts: TopologicalSorter2, sm_dict: SMClusterState):
    """ Show service list ordered by dependency in debug mode"""
    stage=0
    logging.debug(f"Service order by dependency:")
    for mod_i in [ i for i in settings.sm_conf.get_modules() if i not in settings.default_module]: #@todo to rework module support
        logging.debug("--------------------")
        for service_name in sm_dict.get_module_services(sm_dict.get_available_sites()[0],mod_i): #@todo if not
            logging.debug(f"{service_name}")
    while ts and ts.is_active():  # process all services one by one  in  sorted by dependency
        stage += 1
        logging.debug(f"------ Stage {stage} -------")
        for serv in ts.get_ready():
            logging.debug(f"{serv}")
            ts.done(serv)
    logging.debug("Done. ----------------")


def run(services:[] = None, cmd="", site=""):
    """ Business Logic - implements main flow """

    # init SMClusterState object ann get status for all sites in case DR procedure or specific site in case cmd
    sm_dict = sm_get_cluster_state(None)

    # assemble ordered service list to proceed, keeping in services specified in cli
    for site_i in sm_dict.get_available_sites():
        for mod_i in settings.sm_conf.get_modules():
            service_dep_ordered, return_code, ts = make_ordered_services_to_process(sm_dict, site_i, services,mod_i)
            sm_dict[site_i][mod_i]['service_dep_ordered'].extend(service_dep_ordered)
            sm_dict[site_i][mod_i]['ts'] = ts
            sm_dict[site_i][mod_i]['deps_issue'] = not return_code
            logging.debug(f"Site:{site_i} module:{mod_i} list:{sm_dict[site_i][mod_i]['service_dep_ordered']} "
                          f"deps_issue:{sm_dict[site_i][mod_i]['deps_issue']}")

    # validation to satisfy cmd and current site status
    service_dep_ordered = []; ts = None
    try:
        for mod_i in settings.sm_conf.get_modules():
            services_list, ts_i = validate_operation(sm_dict, cmd, site, services, mod_i)
            service_dep_ordered.extend(services_list)
            if mod_i in settings.default_module:
                ts = ts_i
        logging.debug(f"Service order {service_dep_ordered}")
    except NotValid:
        exit(1)

    settings.ignored_services.extend(sm_dict.make_ignored_services(service_dep_ordered))

    # main flow by command
    if cmd in "status":
        for serv in service_dep_ordered:
            def run_in_thread(site, serv, sm_dict):  # to run each status service in parallel
                response, _, return_code=sm_process_service(site, serv, "status")
                if not sm_dict[site]['services'].get(serv):
                    sm_dict[site]['services'][serv]={}
                sm_dict[site]['services'][serv]['status']=ServiceDRStatus(response) if return_code else False

            for site_i in sm_dict.get_available_sites():
                thread=threading.Thread(target=run_in_thread, args=(site_i, serv, sm_dict))
                thread.name = f"Thread: {serv}"
                thread.start()
                thread_pool.append(thread)
        for thread in thread_pool:
            thread.join()
        print_service_order(ts,sm_dict)
        print_main_table(sm_dict, service_dep_ordered, [site] if site else [_ for _ in settings.sm_conf.keys()])
    elif cmd in "list":
        print(f"---------------------------------------------------------------------\n" +
              f"Sites managed by site-manager:               {[site for site in sm_dict.keys()]}\n\n" +
              f"Kubernetes services managed by site-manager: {sm_dict.get_services_list_for_ok_site()}\n" +
              f"Kubernetes services that will be processed:  {service_dep_ordered}\n" +
              f"---------------------------------------------------------------------")
    elif cmd in settings.site_cmds + settings.dr_procedures:  # per site command or DR procedure
        print_service_operation_summary("top", sm_dict, service_dep_ordered, cmd, site)
        dr_status = True
        for elem in settings.module_flow:
            module, states = list(elem.items())[0]
            if not dr_status:  # fail rest of services in case failed before
                for i in sm_dict.get_module_services(sm_dict.get_available_sites()[0], module):
                    if i in service_dep_ordered:
                        ServiceDRStatus({'services':{i:{'status':'failed'}}}).sortout_service_results()
                break
            if cmd in ['standby', 'disable', 'return'] and (states and states == ['active']):
                break
            if cmd in 'active' and (states and set(states) == {'standby', 'disable'}):
                continue
            process_module_services(module, states, cmd, site, sm_dict)
            if settings.failed_services:
                logging.debug(f"Module {module} failed. Failed services {settings.failed_services}")
                logging.error(f"Module {module} failed, skipping rest of services, exiting")
                break
        print_service_operation_summary("tail",sm_dict, service_dep_ordered, cmd, site )
    else:
        logging.error(f"Unknown combination of {cmd} {site} options")
        exit(1)

    if len(settings.failed_services) != 0:
        logging.fatal(f"Some services finished {cmd} with failed status")
        exit(1)

    return True


def print_service_operation_summary(part, sm_dict: SMClusterState, services_to_run: [], cmd="", site=""):
    if part in "top":
        logging.info("---------------------------------------------------------------------")
        logging.info(f"Procedure:     {cmd}")
        logging.info(f"Active sites:  {settings.sm_conf.get_active_site(cmd, site)}")
        logging.info(f"Standby sites: {settings.sm_conf.get_opposite_site(settings.sm_conf.get_active_site(cmd, site))}")
        logging.info(f"Kubernetes services managed by site-manager: {sm_dict.get_services_list_for_ok_site()}")
        logging.info(f"Kubernetes services that will be processed:  {services_to_run}")
        logging.info("---------------------------------------------------------------------")
    elif part in "tail":
        logging.info("---------------------------------------------------------------------")
        logging.info("Summary:")
        logging.info(f"services that successfully done: {list(dict.fromkeys(settings.done_services))}")
        logging.info(f"services that failed:            {settings.failed_services}")
        logging.info(f"services that ignored:           {settings.ignored_services}")
        logging.info("---------------------------------------------------------------------")


def print_main_table(sm_dict: SMClusterState, services_to_run, sites_name: []):
    """ Method intended to display main section of status table
    @param dict sm_dict: the results of the procedure received from the site-manager
    @param list services_to_run: the list of services that have been processed
    @param list sites_name: list of cluster names
    """
    def make_table(header, sites_name):
        """
        Method for creating the main parts of the table
        """

        pt=PrettyTable()
        pt_field_names=["Service"]

        for sites_item in sites_name:
            pt_field_names.append(f"{sites_item}")

        pt.field_names=pt_field_names
        pt.align["Service"]="l"

        # Additional header
        comment_pt_row = [""]
        separator_pt_row = ["--------------------------"]

        for sites_item in sites_name:
            comment_pt_row.append(header)
            separator_pt_row.append("------------------------------------")

        pt.add_row(comment_pt_row)
        pt.add_row(separator_pt_row)
        pt.max_width = 50
        return pt
    pt = make_table("mode | DR status | healthz | message", sites_name)
    for service_item in services_to_run:
        service_pt_row = list()
        service_pt_row.append(service_item)
        for sites_item in sites_name:
            if sm_dict[sites_item]['status'] and sm_dict[sites_item]['services'].get(service_item) and \
                    sm_dict[sites_item]['services'][service_item].get('status'):
                service_pt_row.append(
                    f"{sm_dict[sites_item]['services'][service_item]['status']['mode']} / "
                    f"{sm_dict[sites_item]['services'][service_item]['status']['status']} / "
                    f"{sm_dict[sites_item]['services'][service_item]['status']['healthz']} / "
                    f"{sm_dict[sites_item]['services'][service_item]['status']['message']}")
            else:
                service_pt_row.append("-- / -- / -- /")
        pt.add_row(service_pt_row)

    print(pt)


def parse_command_line(command_args) -> argparse.Namespace:
    """ Main argument parser
    @return:
    """
    parser = argparse.ArgumentParser(description=MAIN_HELP_SECTION,
                                     argument_default=argparse.SUPPRESS,
                                     formatter_class=argparse.RawTextHelpFormatter)

    parser.add_argument('-v', '--verbose', default=False, action='store_true', help='enable the verbosity mode')
    parser.add_argument('-c', '--config', default="", help='define the path to configuration file')
    parser.add_argument('-f', '--force', default=False, action='store_true', help='force apply DR action and ignore healthz')
    parser.add_argument('-k', '--insecure', default=False, action='store_true', help='enable self-signed certificates')
    parser.add_argument('-o', '--output', default="", help='define the filename for logging output')
    parser.add_argument('-r', '--ignore-restrictions', default=False, action='store_true', help='skip state restrictions validation')

    parser.add_argument('--run-services', default='', help='define the list of services to apply DR action, by default all services participate')
    parser.add_argument('--skip-services',  default='', help='define the list of services what will not participate in DR action')

    subparsers = parser.add_subparsers()
    subparsers.required=True

    parser_1 = subparsers.add_parser('move', help='move Active functionality to Standby site')  # DR switchover
    parser_1.add_argument('site', help=SITE_HELP_SECTION)
    parser_1.set_defaults(command='move')

    parser_2 = subparsers.add_parser('stop', help='excludes site from Active-Standby scheme')  # DR failover
    parser_2.add_argument('site', help=SITE_HELP_SECTION)
    parser_2.set_defaults(command='stop')

    parser_3 = subparsers.add_parser('return', help='return stopped Kubernetes cluster to Standby role')
    parser_3.add_argument('site', help=SITE_HELP_SECTION)
    parser_3.set_defaults(command='return')

    parser_4 = subparsers.add_parser('disable', help='stop Standby kubernetes cluster for maintenance')
    parser_4.add_argument('site', help=SITE_HELP_SECTION)
    parser_4.set_defaults(command='disable')

    parser_5 = subparsers.add_parser('active', help='set kubernetes cluster services to active mode')
    parser_5.add_argument('site', help=SITE_HELP_SECTION)
    parser_5.set_defaults(command='active')

    parser_6 = subparsers.add_parser('standby', help='set kubernetes cluster services to standby mode')
    parser_6.add_argument('site', help=SITE_HELP_SECTION)
    parser_6.set_defaults(command='standby')

    parser_7 = subparsers.add_parser('list', help='list all services from Active-Standby scheme managed by site-manager with dependencies')
    parser_7.add_argument('site', nargs='?', default="", help=SITE_HELP_SECTION)
    parser_7.set_defaults(command='list')

    parser_8 = subparsers.add_parser('status', help='show current status of clusters and all services')
    parser_8.add_argument('site', nargs='?', default="", help=SITE_HELP_SECTION)  # todo to update help
    parser_8.set_defaults(command='status')

    parser_9 = subparsers.add_parser('version', help='get current version')
    parser_9.set_defaults(command='version')

    return parser.parse_args(args=command_args)


def main(command_args=None):
    global args
    args = parse_command_line(command_args)

    # get version command
    if args.command in "version":
        with open('../version', 'r') as f:
            print('SM-client %s' % f.read())
        exit(0)

    if not init_and_check_config(args):
        exit(1)

    settings.ignored_services.extend(settings.skip_services)

    if not run([i for i in settings.run_services if i not in settings.skip_services], args.command,
                args.site if hasattr(args, 'site') else False):
        exit(1)
    exit(0)


if __name__ == "__main__":
    main()
