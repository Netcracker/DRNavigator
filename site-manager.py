#!/usr/bin/env python3
"""
Company:     NetCracker
Author:      Core PaaS Group
Version:     0.5
Date:        2021-05-26
Description: Service for management of microservices in active-standby scheme of kubernetes cluster
"""

import importlib.util
import logging
import threading
import time
import http
import copy
import utils
from flask import Flask, request, jsonify, make_response
from kubernetes import client, config
from prometheus_flask_exporter import PrometheusMetrics
from prometheus_client import Gauge


# List of possible procedures
command_list = ["active", "standby", "disable", "list", "status"]

app = Flask(__name__)

app.config['DEBUG'] = utils.SM_DEBUG
app.config['JSONIFY_PRETTYPRINT_REGULAR'] = True
metrics = PrometheusMetrics(app)

site_manager_health = Gauge('site_manager_health', 'SM pod health')

if utils.SM_DEBUG:
    logging_level = logging.DEBUG
    logging_format = "[%(asctime)s] [%(process)d] [%(levelname)s] %(filename)s.%(funcName)s(%(lineno)d): %(message)s"
else:
    logging_level = logging.INFO
    logging_format = "[%(asctime)s] [%(process)d] [%(levelname)s] %(filename)s: %(message)s"

logging.basicConfig(format=logging_format, level=logging_level)

lock = threading.Lock()


if utils.FRONT_HTTP_AUTH or utils.BACK_HTTP_AUTH:
    utils.get_token(False)

    w_thread = threading.Thread(target=utils.get_token,
                                args=[True, ])
    w_thread.start()


def get_sitemanagers_dict():
    """
    Method creates dictionary of donwloaded data from sitemanager CRs
    """

    # In testing mode return stab
    if utils.SM_CONFIG.get("testing", {}).get("enabled", False) and \
       utils.SM_CONFIG.get("testing", {}).get("sm_dict", {}) != {}:

       return utils.SM_CONFIG["testing"]["sm_dict"]

    if utils.SM_KUBECONFIG_FILE != "":
        k8s_api_client = config.load_kube_config(config_file=utils.SM_KUBECONFIG_FILE)

    else:
        k8s_api_client = config.load_incluster_config()

    try:
        response = client.CustomObjectsApi(api_client=k8s_api_client).list_cluster_custom_object(group=utils.SM_GROUP,
                                                                                                 version=utils.SM_VERSION,
                                                                                                 plural=utils.SM_PLURAL,
                                                                                                 _request_timeout=10)

    except Exception as e:
        logging.error("Can not download sitemanager objects: \n %s" % str(e))
        return {}

    output = dict()
    output['services'] = {}
    for item in response["items"]:
        module_name = item['spec']['sitemanager'].get('module', '')
        module = import_module(module_name)
        output['services'][item['metadata'].get('name')] = module.get_module_specific_cr(item)

    return output


def check_dependencies(services_to_run, all_services, sm_dict):
    """
    Method to check dependencies between services that will be processed

    :param list services_to_run: the list of services generated  get_services_to_run() and that will be processed
    :param all_services: the list of all services from kubernetes clusters managed by site-manager
    :param dict sm_dict: the dictionary generated by get_sitemanagers_dict() and based on CRs from kubernetes clusters
    """

    dep_dict = {}

    logging.info(f"Services: {services_to_run}. Check for nonexistent dependencies.")
    for item in services_to_run:
        depends = sm_dict["services"][item]['after']
        if "stateful" in depends and len(depends) == 1:
            continue
        if not all(elem in all_services for elem in depends):
            dep_dict[item] = []
            for after_item in sm_dict['services'][item]['after']:
                if after_item not in all_services:
                    dep_dict[item].append(after_item)

    if len(dep_dict) > 0:
        for dep_item in dep_dict:
            logging.critical(f"Service: {dep_item}. Service has nonexistent dependencies: {dep_dict[dep_item]}")

        exit(1)

    logging.info(f"Services: {services_to_run}. Services don\'t have nonexistent dependencies")


def get_all_services(sm_dict):
    """
    Method for definition of list of all services in kubernetes cluster managed by site-manager

    :param dict sm_dict: the dictionary generated by get_sitemanagers_dict() and based on CRs from kubernetes clusters
    """

    return list(set([ i for i in sm_dict["services"].keys() ]))


def get_services_to_run(run_services, skip_services, all_services):
    """
    Method for definition of list of services to be processed

    :param list run_services: the list of services that defined by parameter run-services
    :param list skip_services: the list of services that defined by parameter skip-services
    :param list all_services: the list of all services from kubernetes clusters managed by site-manager
    """

    if len(run_services) != 0:
        services_to_run = []
        for item in run_services:
            if item in all_services:
                services_to_run.append(item)
            else:
                logging.fatal(f"Service {item} does not exist in provided kubernetes clusters")
                exit(1)

    elif len(skip_services) != 0:
        services_to_run = all_services.copy()
        for item in skip_services:
            if item in all_services:
                services_to_run.remove(item)
            else:
                logging.fatal(f"Service {item} does not exist in provided kubernetes clusters")
                exit(1)

    else:
        services_to_run = all_services.copy()

    return services_to_run


def json_response(code, body):
    """
    Method to perform json output
    :param int code: http code for operation
    :param dict body: dict with message or lists for http response
    """
    response = make_response(jsonify(body), code,)
    response.headers["Content-Type"] = "application/json"

    return response


def import_module(services_module):
    """
    Method for importing a module

    :param string services_module: module name
    """

    logging.info("loading module: %s" % services_module)
    spec = importlib.util.spec_from_file_location(services_module, "modules/" + services_module + ".py")
    module = importlib.util.module_from_spec(spec)
    spec.loader.exec_module(module)
    return module


@app.route('/', methods=['GET'])
def root_get():
    """
    Method for processing GET requests to /

    Right now is under construction and will be completely changed
    """

    return "Under construction"


@app.route('/validate', methods=['POST'])
def cr_validate():
    pass


@app.route('/convert', methods=['POST'])
def cr_convert():

    logging.debug(f"Initial object from API: {request.json['request']}")

    spec = request.json["request"]["objects"]
    modified_spec = copy.deepcopy(spec)
    for i in range(len(modified_spec)):
        # v1->v2 conversion
        if request.json["request"]["desiredAPIVersion"] == "netcracker.com/v2":
            modified_spec[i]["apiVersion"] = request.json["request"]["desiredAPIVersion"]

            if "module" not in modified_spec[i]["spec"]["sitemanager"]:
                modified_spec[i]["spec"]["sitemanager"]["module"] = modified_spec[i]["spec"]["sitemanager"].get("module", "stateful")

            if "parameters" not in modified_spec[i]["spec"]["sitemanager"]:
                modified_spec[i]["spec"]["sitemanager"]["parameters"] = {}
                modified_spec[i]["spec"]["sitemanager"]["parameters"]["serviceEndpoint"] = modified_spec[i]["spec"]["sitemanager"].pop("serviceEndpoint", "")
                modified_spec[i]["spec"]["sitemanager"]["parameters"]["ingressEndpoint"] = modified_spec[i]["spec"]["sitemanager"].pop("ingressEndpoint", "")
                modified_spec[i]["spec"]["sitemanager"]["parameters"]["healthzEndpoint"] = modified_spec[i]["spec"]["sitemanager"].pop("healthzEndpoint", "")
        # v2->v1 conversion
        if request.json["request"]["desiredAPIVersion"] == "netcracker.com/v1":
            modified_spec[i]["apiVersion"] = request.json["request"]["desiredAPIVersion"]

            if "module" in modified_spec[i]["spec"]["sitemanager"]:
                del modified_spec[i]["spec"]["sitemanager"]["module"]

            if "parameters" in modified_spec[i]["spec"]["sitemanager"]:
                modified_spec[i]["spec"]["sitemanager"]["serviceEndpoint"] = modified_spec[i]["spec"]["sitemanager"]["parameters"].pop("serviceEndpoint", "")
                modified_spec[i]["spec"]["sitemanager"]["ingressEndpoint"] = modified_spec[i]["spec"]["sitemanager"]["parameters"].pop("ingressEndpoint", "")
                modified_spec[i]["spec"]["sitemanager"]["healthzEndpoint"] = modified_spec[i]["spec"]["sitemanager"]["parameters"].pop("healthzEndpoint", "")
                del modified_spec[i]["spec"]["sitemanager"]["parameters"]

    logging.debug("CR convertation is started.")
    logging.debug(f"Initial spec: {spec}")
    logging.debug(f"Modified spec: {modified_spec}")

    return jsonify(
        {
            "apiVersion": "apiextensions.k8s.io/v1",
            "kind": "ConversionReview",
            "response": {
                "uid": request.json["request"]["uid"],
                "result": {
                    "status": "Success"
                },
                "convertedObjects": modified_spec
            }
        }
    )


@app.route("/health", methods=["GET"])
def health():
    site_manager_health.set(1)
    return ("", http.HTTPStatus.NO_CONTENT)


@app.route('/sitemanager', methods=['GET'])
def sitemanager_get():
    """
    Method for processing GET requests to /sitemanager
    """
    result = check_authorization(request)
    if result:
        return result

    try:
        response = json_response(200, get_sitemanagers_dict())
    except Exception as e:
        logging.error(str(e))
        response = json_response(500, {"message": "Can not get sitemanager structures"})

    return response


@app.route('/sitemanager', methods=['POST'])
def sitemanager_post():
    """
    Method for processing POST requests to /sitemanager
    """

    result = check_authorization(request)
    if result:
        return result

    try:
        data = request.get_json()

    except Exception as e:
        logging.error("Some problem occurred: \n %s" % str(e))
        return json_response(400, {"message": "No valid JSON data was received"})

    logging.info(f"Data was received: {data}")

    # Check all parameters in received data
    if data.get("procedure", "") not in command_list:

        return json_response(400, {"message": f"You should define procedure from list: {command_list}"})

    force = True if data.get("force", "") in (1, "1", True, "true", "True") else False
    no_wait = True if data.get("no-wait", "") in (1, "1", True, "true", "True") else False

    # Check services for running
    if data.get("run-services", "") != "":

        if type(data["run-services"]) == type([]) and hasattr(data["run-services"], "__iter__"):
            run_services = data["run-services"]
        else:
            run_services = data["run-services"].replace(',', ' ').replace('  ', ' ').split(' ')
    else:
        run_services = []

    # Check services for skipping
    if data.get("skip-services", "") != "" and len(run_services) == 0:

        if type(data["skip-services"]) == type([]) and hasattr(data["skip-services"], "__iter__"):
            skip_services = data["skip-services"]
        else:
            skip_services = data["skip-services"].replace(',', ' ').replace('  ', ' ').split(' ')
    else:
        skip_services = []

    sm_dict = get_sitemanagers_dict()
    all_services = get_all_services(sm_dict)

    # Check for service what does not exist in cluster
    wrong_services = [elem for elem in (run_services + skip_services) if elem not in all_services]

    if len(wrong_services) > 0:

        return json_response(400, {"message": f"You defined service that does not exist in cluster",
                                   "wrong-services": wrong_services})

    services_to_run = get_services_to_run(run_services, skip_services, all_services)
    logging.info(f"Following services will be processed: {services_to_run}")

    if data["procedure"] == "list":

        return json_response(200, {"all-services": all_services,
                                   "running-services": services_to_run})

    if data["procedure"] == "status":
        output = dict()
        output["services"] = {}
        for item in services_to_run:
            module = import_module(sm_dict["services"][item]["module"])
            output["services"][item] = module.get_status(sm_dict["services"][item], **data)
        return json_response(200, output)

    logging.info(f"Start process services: {services_to_run}")

    failed_services = []
    for service in services_to_run:
            module = import_module(sm_dict["services"][service]["module"])
            resp = utils.send_post(url=sm_dict["services"][service]['parameters']["serviceEndpoint"],
                            mode=data["procedure"],
                           no_wait=no_wait)
            if resp.get("bad_response") or resp.get("fatal"):
                failed_services.append(service)

    if failed_services:
        return json_response(500, {"message": f"Procedure {data['procedure']} failed",
                                   "services-failed": failed_services,
                                   "services": services_to_run,
                                   "procedure": data['procedure']})
    else:
        return json_response(200, {"message": f"Procedure {data['procedure']} is started",
                                   "services": services_to_run,
                                   "procedure": data['procedure']})


def check_authorization(request):
    if utils.FRONT_HTTP_AUTH:
        if "Authorization" not in request.headers:
            return json_response(401, {"message": "You should use Bearer for authorization"})

        if len(request.headers["Authorization"].split(" ")) != 2 or \
           request.headers["Authorization"].split(" ")[1] != utils.SM_AUTH_TOKEN:
            return json_response(403, {"message": "Bearer is empty or wrong"})
