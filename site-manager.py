#!/usr/bin/env python3
"""
Company:     NetCracker
Author:      Core PaaS Group
Version:     0.5
Date:        2021-05-26
Description: Service for management of microservices in active-standby scheme of kubernetes cluster
"""

import importlib.util
import logging
import threading
import time
import http
import copy
import utils
from flask import Flask, request, jsonify, make_response
from kubernetes import client, config
from prometheus_flask_exporter import PrometheusMetrics
from prometheus_client import Gauge


# List of possible procedures
command_list = ["active", "standby", "disable", "list", "status"]

app = Flask(__name__)

app.config['DEBUG'] = utils.SM_DEBUG
app.config['JSONIFY_PRETTYPRINT_REGULAR'] = True
metrics = PrometheusMetrics(app)

site_manager_health = Gauge('site_manager_health', 'SM pod health')

if utils.SM_DEBUG:
    logging_level = logging.DEBUG
    logging_format = "[%(asctime)s] [%(process)d] [%(levelname)s] %(filename)s.%(funcName)s(%(lineno)d): %(message)s"
else:
    logging_level = logging.INFO
    logging_format = "[%(asctime)s] [%(process)d] [%(levelname)s] %(filename)s: %(message)s"

logging.basicConfig(format=logging_format, level=logging_level)

lock = threading.Lock()


if utils.FRONT_HTTP_AUTH or utils.BACK_HTTP_AUTH:
    utils.get_token(False)

    w_thread = threading.Thread(target=utils.get_token,
                                args=[True, ])
    w_thread.start()


def get_sitemanagers_dict():
    """
    Method creates dictionary of donwloaded data from sitemanager CRs
    """

    # In testing mode return stab
    if utils.SM_CONFIG.get("testing", {}).get("enabled", False) and \
       utils.SM_CONFIG.get("testing", {}).get("sm_dict", {}) != {}:

       return utils.SM_CONFIG["testing"]["sm_dict"]

    if utils.SM_KUBECONFIG_FILE != "":
        k8s_api_client = config.load_kube_config(config_file=utils.SM_KUBECONFIG_FILE)

    else:
        k8s_api_client = config.load_incluster_config()

    try:
        response = client.CustomObjectsApi(api_client=k8s_api_client).list_cluster_custom_object(group=utils.SM_GROUP,
                                                                                                 version=utils.SM_VERSION,
                                                                                                 plural=utils.SM_PLURAL,
                                                                                                 _request_timeout=10)

    except Exception as e:
        logging.error("Can not download sitemanager objects: \n %s" % str(e))
        return {}

    output = dict()
    output['services'] = {}
    for item in response["items"]:
        output['services'][item['metadata'].get('name')] = get_module_specific_cr(item)

    return output


def get_all_services(sm_dict):
    """
    Method for definition of list of all services in kubernetes cluster managed by site-manager

    :param dict sm_dict: the dictionary generated by get_sitemanagers_dict() and based on CRs from kubernetes clusters
    """

    return list(set([ i for i in sm_dict["services"].keys() ]))


def get_services_to_run(run_services, skip_services, all_services):
    """
    Method for definition of list of services to be processed

    :param list run_services: the list of services that defined by parameter run-services
    :param list skip_services: the list of services that defined by parameter skip-services
    :param list all_services: the list of all services from kubernetes clusters managed by site-manager
    """

    if len(run_services) != 0:
        services_to_run = []
        for item in run_services:
            if item in all_services:
                services_to_run.append(item)
            else:
                logging.fatal(f"Service {item} does not exist in provided kubernetes clusters")
                exit(1)

    elif len(skip_services) != 0:
        services_to_run = all_services.copy()
        for item in skip_services:
            if item in all_services:
                services_to_run.remove(item)
            else:
                logging.fatal(f"Service {item} does not exist in provided kubernetes clusters")
                exit(1)

    else:
        services_to_run = all_services.copy()

    return services_to_run


def json_response(code, body):
    """
    Method to perform json output
    :param int code: http code for operation
    :param dict body: dict with message or lists for http response
    """
    response = make_response(jsonify(body), code,)
    response.headers["Content-Type"] = "application/json"

    return response


def get_status(service, *args, **kwargs):
    """
    Method that collects complete information about the state of the service

    :param dict service: service's CR
    """

    output = dict()
    status = utils.send_get(service['parameters']["serviceEndpoint"])
    output["mode"] = status.get("mode", "--")
    output["status"] = status.get("status", "--")
    output["message"] = status.get("message", "")
    if service['parameters'].get("healthzEndpoint", "") != "":
        healthz = utils.send_get(service['parameters']["healthzEndpoint"])
        output["healthz"] = healthz.get("status", "--")
    else:
        output["healthz"] = "--"

    return output


def get_module_specific_cr(item):
    """
    Method preparing dictionary based on the service's CR

    :param dict item: service's CR
    """

    if item['spec']['sitemanager']['parameters'].get('serviceEndpoint', '') != '':

        if item["spec"]["sitemanager"]['parameters']["serviceEndpoint"].startswith("http://") or \
                item["spec"]["sitemanager"]['parameters']["serviceEndpoint"].startswith("https://"):
            service_endpoint = item["spec"]["sitemanager"]['parameters']["serviceEndpoint"]
        else:
            service_endpoint = utils.HTTP_SCHEME + item["spec"]["sitemanager"]['parameters']["serviceEndpoint"]
    else:
        service_endpoint = ''

    if item['spec']['sitemanager']['parameters'].get('healthzEndpoint', '') != '':

        if item['spec']['sitemanager']['parameters']['healthzEndpoint'].startswith("http://") or \
                item['spec']['sitemanager']['parameters']['healthzEndpoint'].startswith("https://"):
            healthz_endpoint = item['spec']['sitemanager']['parameters']['healthzEndpoint']
        else:
            healthz_endpoint = utils.HTTP_SCHEME + item['spec']['sitemanager']['parameters']['healthzEndpoint']
    else:
        healthz_endpoint = ''
    allowed_standby_state_list = [i.lower() for i in item['spec']['sitemanager'].get('allowedStandbyStateList', ["up"])]

    return {"namespace": item["metadata"]["namespace"],
            "module": item['spec']['sitemanager'].get('module', ''),
            "after": item['spec']['sitemanager'].get('after', []),
            "before": item['spec']['sitemanager'].get('before', []),
            "sequence": item['spec']['sitemanager'].get('sequence', []),
            "allowedStandbyStateList": allowed_standby_state_list,
            "timeout": item['spec']['sitemanager'].get('timeout', utils.SERVICE_DEFAULT_TIMEOUT),
            "parameters":
                {"serviceEndpoint": service_endpoint,
                 "healthzEndpoint": healthz_endpoint}}


@app.route('/', methods=['GET'])
def root_get():
    """
    Method for processing GET requests to /

    Right now is under construction and will be completely changed
    """

    return "Under construction"


@app.route('/validate', methods=['POST'])
def cr_validate():
    pass


@app.route('/convert', methods=['POST'])
def cr_convert():

    logging.debug(f"Initial object from API: {request.json['request']}")

    spec = request.json["request"]["objects"]
    modified_spec = copy.deepcopy(spec)
    for i in range(len(modified_spec)):
        # v1->v2 conversion
        if request.json["request"]["desiredAPIVersion"] == "netcracker.com/v2":
            modified_spec[i]["apiVersion"] = request.json["request"]["desiredAPIVersion"]

            if "module" not in modified_spec[i]["spec"]["sitemanager"]:
                modified_spec[i]["spec"]["sitemanager"]["module"] = modified_spec[i]["spec"]["sitemanager"].get("module", "stateful")

            if "parameters" not in modified_spec[i]["spec"]["sitemanager"]:
                modified_spec[i]["spec"]["sitemanager"]["parameters"] = {}
                modified_spec[i]["spec"]["sitemanager"]["parameters"]["serviceEndpoint"] = modified_spec[i]["spec"]["sitemanager"].pop("serviceEndpoint", "")
                modified_spec[i]["spec"]["sitemanager"]["parameters"]["ingressEndpoint"] = modified_spec[i]["spec"]["sitemanager"].pop("ingressEndpoint", "")
                modified_spec[i]["spec"]["sitemanager"]["parameters"]["healthzEndpoint"] = modified_spec[i]["spec"]["sitemanager"].pop("healthzEndpoint", "")
        # v2->v1 conversion
        if request.json["request"]["desiredAPIVersion"] == "netcracker.com/v1":
            modified_spec[i]["apiVersion"] = request.json["request"]["desiredAPIVersion"]

            if "module" in modified_spec[i]["spec"]["sitemanager"]:
                del modified_spec[i]["spec"]["sitemanager"]["module"]

            if "parameters" in modified_spec[i]["spec"]["sitemanager"]:
                modified_spec[i]["spec"]["sitemanager"]["serviceEndpoint"] = modified_spec[i]["spec"]["sitemanager"]["parameters"].pop("serviceEndpoint", "")
                modified_spec[i]["spec"]["sitemanager"]["ingressEndpoint"] = modified_spec[i]["spec"]["sitemanager"]["parameters"].pop("ingressEndpoint", "")
                modified_spec[i]["spec"]["sitemanager"]["healthzEndpoint"] = modified_spec[i]["spec"]["sitemanager"]["parameters"].pop("healthzEndpoint", "")
                del modified_spec[i]["spec"]["sitemanager"]["parameters"]

    logging.debug("CR convertation is started.")
    logging.debug(f"Initial spec: {spec}")
    logging.debug(f"Modified spec: {modified_spec}")

    return jsonify(
        {
            "apiVersion": "apiextensions.k8s.io/v1",
            "kind": "ConversionReview",
            "response": {
                "uid": request.json["request"]["uid"],
                "result": {
                    "status": "Success"
                },
                "convertedObjects": modified_spec
            }
        }
    )


@app.route("/health", methods=["GET"])
def health():
    site_manager_health.set(1)
    return ("", http.HTTPStatus.NO_CONTENT)


@app.route('/sitemanager', methods=['GET'])
def sitemanager_get():
    """
    Method for processing GET requests to /sitemanager
    """
    result = check_authorization(request)
    if result:
        return result

    try:
        response = json_response(200, get_sitemanagers_dict())
    except Exception as e:
        logging.error(str(e))
        response = json_response(500, {"message": "Can not get sitemanager structures"})

    return response


@app.route('/sitemanager', methods=['POST'])
def sitemanager_post():
    """
    Method for processing POST requests to /sitemanager
    """

    result = check_authorization(request)
    if result:
        return result

    try:
        data = request.get_json()

    except Exception as e:
        logging.error("Some problem occurred: \n %s" % str(e))
        return json_response(400, {"message": "No valid JSON data was received"})

    logging.info(f"Data was received: {data}")

    # Check all parameters in received data
    if data.get("procedure", "") not in command_list:

        return json_response(400, {"message": f"You should define procedure from list: {command_list}"})

    no_wait = True if data.get("no-wait", "") in (1, "1", True, "true", "True") else False

    sm_dict = get_sitemanagers_dict()
    all_services = get_all_services(sm_dict)

    if data["procedure"] == "list":
        return json_response(200, {"all-services": all_services})

    # Check services for running
    if isinstance(data.get("run-service", None), str):
        run_service = data["run-service"]
    else:
        return json_response(400, {"message": f"run-service value should be defined and have String type"})

    # Check for service what does not exist in cluster
    if run_service not in all_services:

        return json_response(400, {"message": f"You defined service that does not exist in cluster",
                                   "wrong-service": run_service})

    logging.info(f"Following service will be processed: {run_service}")

    if data["procedure"] == "status":
        output = dict()
        output["services"] = {}
        output["services"][run_service] = get_status(sm_dict["services"][run_service], **data)
        return json_response(200, output)

    mode = data["procedure"]
    url = sm_dict["services"][run_service]['parameters']['serviceEndpoint']
    logging.info(f"Service: {run_service}. Set mode {mode}. serviceEndpoint = {url}. No-wait {no_wait}")
    resp = utils.send_post(url=url, mode=mode, no_wait=no_wait) 
    if resp.get("bad_response") or resp.get("fatal"):
        return json_response(500, {"message": f"Procedure {data['procedure']} failed",
                                   "service": run_service,
                                   "procedure": data['procedure']})
    else:
        return json_response(200, {"message": f"Procedure {data['procedure']} is started",
                                   "service": run_service,
                                   "procedure": data['procedure']})


def check_authorization(request):
    if utils.FRONT_HTTP_AUTH:
        if "Authorization" not in request.headers:
            return json_response(401, {"message": "You should use Bearer for authorization"})

        if len(request.headers["Authorization"].split(" ")) != 2 or \
           request.headers["Authorization"].split(" ")[1] != utils.SM_AUTH_TOKEN:
            return json_response(403, {"message": "Bearer is empty or wrong"})
