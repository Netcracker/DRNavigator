#!/usr/bin/env python3.9
"""
Company:     NetCracker 
Author:      Core PaaS Group
Version:     0.7
Date:        2021-11-19
Description: Client util to communicate with site-manager in kubernetes based clusters
@todo[3]
    split current single source into modules,classes ; share common code with sm
    make smclient delivery as single binary, using pyinstaller ???
    cli json output
    SM specific data structures : sm_dict; service response: 50%
"""

import argparse
import copy
import logging
import pathlib
import sys
import threading
from graphlib import CycleError

import yaml
import os

from prettytable import PrettyTable
from typing import Tuple, Optional

import utils
from sm_client.processing import sm_process_service, thread_pool, process_module_services
from sm_client.data.structures import *
from sm_client.validation import validate_operation

MAIN_HELP_SECTION = """
Script to manage DR cases in kubernetes Active-Standby scheme

How to use commands:

  +------------------------------+        +------------------------------+
  |      INITIAL CONDITION       |        |        FINAL CONDITION       |
  +--------------+---------------+--------+--------------+---------------+-----+---------+
  | ACTIVE SITE  | STANDBY SITE  |  ===>  | ACTIVE SITE  | STANDBY SITE  |     | COMMAND |
  +--------------+---------------+  ===>  +--------------+---------------+     +---------+
  | ACTIVE       | STANDBY       |  ===>  | STANDBY      | ACTIVE        |  =  | move    |
  | failed       | STANDBY       |  ===>  | stopped      | ACTIVE        |  =  | stop    |
  | stopped      | ACTIVE        |  ===>  | STANDBY      | ACTIVE        |  =  | return  |
  | ACTIVE       | stopped       |  ===>  | ACTIVE       | STANDBY       |  =  | return  |
  | ACTIVE       | STANDBY       |  ===>  | ACTIVE       | stopped       |  =  | disable |
  +--------------+---------------+--------+--------------+---------------+-----+---------+
"""
SITE_HELP_SECTION = """define the cluster name.
This site:
  will be active in case of move 
  will be standby in case of stop
  will be standby in case of return
  will be disable to maintenance in case of disable
"""

args: argparse.Namespace


def init_and_check_config(args) -> bool:
    """ Main entry point. Provides validations, config parsing and initialization
    @returns: True of False  """
    #@todo python version check; version print

    # Set verbosity for logging
    logger = logging.getLogger()
    logger.setLevel(logging.DEBUG)

    ch = logging.StreamHandler()
    if args.verbose:
        ch.setLevel(logging.DEBUG)
        ch.setFormatter(logging.Formatter("%(asctime)s [%(levelname)s] %(filename)s.%(funcName)s(%(lineno)d): %(message)s"))
    else:
        ch.setLevel(logging.INFO)
        ch.setFormatter(logging.Formatter("%(asctime)s [%(levelname)s] %(filename)s: %(message)s"))

    logging.basicConfig(handlers=[ch])
    if args.output:
        log_output = None
        if pathlib.Path(args.output).is_file():
            log_output = pathlib.Path(args.output).expanduser() if os.access(args.output, os.W_OK) else None
        elif os.access(pathlib.Path(args.output).expanduser().parent.resolve(), os.W_OK) and \
                not pathlib.Path(args.output).expanduser().is_dir(): # do not take into account provided dirs
            log_output = pathlib.Path(args.output).expanduser()

        if not log_output:
            logging.critical(f"Cannot write to {args.output} file. Printing stdout ...")
        else:
            fh = logging.FileHandler(log_output)
            fh.setLevel(logging.DEBUG)
            fh.setFormatter(logging.Formatter("%(asctime)s [%(levelname)s] %(filename)s.%(funcName)s(%(lineno)d): %(message)s"))
            fh.emit(logging.LogRecord("",logging.INFO,sys.argv[0], 0, args.command,None,None)) # add delimeter in logfile

            logger.addHandler(fh)

    logging.debug(f"Script arguments: {args}")

    # Define, check and load configuration file
    conf_file = os.path.join(os.path.dirname(os.path.abspath(__file__)), "config.yaml") if args.config == "" else args.config
    if not os.path.isfile(conf_file):
        logging.fatal("You should define configuration file for site-manager or copy it to config.yaml in site-manager main directory")
        exit(1)

    try:
        conf_parsed = yaml.load(open(conf_file), Loader=yaml.FullLoader)
    except:
        logging.fatal("Can not parse configuration file!")
        return False

    logging.debug(f"Parsed config: {conf_parsed}")

    settings.FRONT_HTTP_AUTH = conf_parsed.get("sm-client", {}).get("http_auth", False)
    settings.SERVICE_DEFAULT_TIMEOUT = conf_parsed.get("sm-client", {}).get("service_default_timeout", 200)

    utils.SM_GET_REQUEST_TIMEOUT = conf_parsed.get("sm-client", {}).get("get_request_timeout", 10)
    utils.SM_POST_REQUEST_TIMEOUT = conf_parsed.get("sm-client", {}).get("post_request_timeout", 30)

    settings.ignored_services.clear()

    # Check services for running
    if args.run_services != '':
        settings.run_services = args.run_services.replace(',', ' ').replace('  ', ' ').split(' ')
    else:
        settings.run_services.clear()

    if args.skip_services != '':
        settings.skip_services = args.skip_services.replace(',', ' ').replace('  ', ' ').split(' ')
    else:
        settings.skip_services.clear()

    settings.failed_services.clear()

    settings.force = args.force

    settings.state_restrictions = conf_parsed.get("restrictions", {}) if not args.ignore_restrictions else {}

    settings.module_flow = conf_parsed.get("flow", [{'stateful': None}])
    site_names = [i["name"] for i in conf_parsed["sites"]]
    settings.sm_conf = SMConf()
    for site in site_names:
        try:
            site_url = [ i["site-manager"] for i in conf_parsed["sites"] if i ["name"] == site ][0]
        except KeyError:
            logging.error("Check configuration file. Some of sites does not have 'site-manager' parameter")
            return False

        for i in conf_parsed["sites"]:
            if i["name"] != site:
                continue
            if isinstance(i.get("token", ""), dict):
                if "from_env" not in i.get("token", {}):
                    logging.error(f"Wrong token configuration for site {i['name']}: "
                                  f"use string value or specify from_env parameter")
                    return False
                site_token = os.environ.get(i["token"]["from_env"])
                if site_token is None:
                    logging.error(f"Wrong token configuration for site {i['name']}: "
                                  f"specified env {i['token']['from_env']} doesn't exist")
                    return False
            else:
                site_token = i.get("token", "")
        site_cacert = [ i.get("cacert", True) for i in conf_parsed["sites"] if i ["name"] == site ][0]

        if site_cacert != True and not os.path.isfile(site_cacert):
            logging.fatal(f"You should define correct path to CA certificate for site {site}")
            return False
        settings.sm_conf[site] = {}
        settings.sm_conf[site]["url"] = site_url
        settings.sm_conf[site]["token"] = site_token
        settings.sm_conf[site]["cacert"] = False if args.insecure else site_cacert

    # Check state restrictions
    for restrictions_list in settings.state_restrictions.values():
        if any(state_str.count('-') + 1 != len(settings.sm_conf) for state_str in restrictions_list):
            logging.error(f"Check configuration file. Some state restrictions don't suitable for the current number of sites")
            return False

    return True


def sm_get_cluster_state(site=None) -> SMClusterState:
    """ Get cluster status or per specific site and init sm_dict object
    """
    sm_dict = SMClusterState(site)
    for site_name in sm_dict.keys():
        response, ret, code = sm_process_service(site_name, "site-manager", "status")
        sm_dict[site_name]["return_code"] = code # HTTP or SSL
        sm_dict[site_name]["status"] = ret
        sm_dict[site_name].update(response)
    return sm_dict


def print_service_order(ts: TopologicalSorter2, sm_dict: SMClusterState):
    """ Show service list ordered by dependency in debug mode"""
    stage=0
    logging.debug(f"Service order by dependency:")
    for mod_i in [ i for i in settings.sm_conf.get_modules() if i not in settings.default_module]: #@todo to rework module support
        logging.debug("--------------------")
        for service_name in sm_dict.get_module_services(sm_dict.get_available_sites()[0],mod_i): #@todo if not
            logging.debug(f"{service_name}")
    while ts and ts.is_active():  # process all services one by one  in  sorted by dependency
        stage += 1
        logging.debug(f"------ Stage {stage} -------")
        for serv in ts.get_ready():
            logging.debug(f"{serv}")
            ts.done(serv)
    logging.debug("Done. ----------------")


def run(services:[] = None, cmd="", site=""):
    """ Business Logic - implements main flow """

    # init SMClusterState object ann get status for all sites in case DR procedure or specific site in case cmd
    sm_dict = sm_get_cluster_state(None)

    # assemble ordered service list to proceed, keeping in services specified in cli
    for site_i in sm_dict.get_available_sites():
        for mod_i in settings.sm_conf.get_modules():
            service_dep_ordered, return_code, ts = make_ordered_services_to_process(sm_dict, site_i, services,mod_i)
            sm_dict[site_i][mod_i]['service_dep_ordered'].extend(service_dep_ordered)
            sm_dict[site_i][mod_i]['ts'] = ts
            sm_dict[site_i][mod_i]['deps_issue'] = not return_code
            logging.debug(f"Site:{site_i} module:{mod_i} list:{sm_dict[site_i][mod_i]['service_dep_ordered']} "
                          f"deps_issue:{sm_dict[site_i][mod_i]['deps_issue']}")

    # validation to satisfy cmd and current site status
    service_dep_ordered = []; ts = None
    try:
        for mod_i in settings.sm_conf.get_modules():
            services_list, ts_i = validate_operation(sm_dict, cmd, site, services, mod_i)
            service_dep_ordered.extend(services_list)
            if mod_i in settings.default_module:
                ts = ts_i
        logging.debug(f"Service order {service_dep_ordered}")
    except NotValid:
        exit(1)

    settings.ignored_services.extend(sm_dict.make_ignored_services(service_dep_ordered))

    # main flow by command
    if cmd in "status":
        for serv in service_dep_ordered:
            def run_in_thread(site, serv, sm_dict):  # to run each status service in parallel
                response, _, return_code=sm_process_service(site, serv, "status")
                if not sm_dict[site]['services'].get(serv):
                    sm_dict[site]['services'][serv]={}
                sm_dict[site]['services'][serv]['status']=ServiceDRStatus(response) if return_code else False

            for site_i in sm_dict.get_available_sites():
                thread=threading.Thread(target=run_in_thread, args=(site_i, serv, sm_dict))
                thread.name = f"Thread: {serv}"
                thread.start()
                thread_pool.append(thread)
        for thread in thread_pool:
            thread.join()
        print_service_order(ts,sm_dict)
        print_main_table(sm_dict, service_dep_ordered, [site] if site else [_ for _ in settings.sm_conf.keys()])
    elif cmd in "list":
        print(f"---------------------------------------------------------------------\n" +
              f"Sites managed by site-manager:               {[site for site in sm_dict.keys()]}\n\n" +
              f"Kubernetes services managed by site-manager: {sm_dict.get_services_list_for_ok_site()}\n" +
              f"Kubernetes services that will be processed:  {service_dep_ordered}\n" +
              f"---------------------------------------------------------------------")
    elif cmd in settings.site_cmds + settings.dr_procedures:  # per site command or DR procedure
        print_service_operation_summary("top", sm_dict, service_dep_ordered, cmd, site)
        dr_status = True
        for elem in settings.module_flow:
            module, states = list(elem.items())[0]
            if not dr_status:  # fail rest of services in case failed before
                for i in sm_dict.get_module_services(sm_dict.get_available_sites()[0], module):
                    if i in service_dep_ordered:
                        ServiceDRStatus({'services':{i:{'status':'failed'}}}).sortout_service_results()
                break
            if cmd in ['standby', 'disable', 'return'] and (states and states == ['active']):
                break
            if cmd in 'active' and (states and set(states) == {'standby', 'disable'}):
                continue
            process_module_services(module, states, cmd, site, sm_dict)
            if settings.failed_services:
                logging.debug(f"Module {module} failed. Failed services {settings.failed_services}")
                logging.error(f"Module {module} failed, skipping rest of services, exiting")
                break
        print_service_operation_summary("tail",sm_dict, service_dep_ordered, cmd, site )
    else:
        logging.error(f"Unknown combination of {cmd} {site} options")
        exit(1)

    if len(settings.failed_services) != 0:
        logging.fatal(f"Some services finished {cmd} with failed status")
        exit(1)

    return True


def print_service_operation_summary(part, sm_dict: SMClusterState, services_to_run: [], cmd="", site=""):
    if part in "top":
        logging.info("---------------------------------------------------------------------")
        logging.info(f"Procedure:     {cmd}")
        logging.info(f"Active sites:  {settings.sm_conf.get_active_site(cmd, site)}")
        logging.info(f"Standby sites: {settings.sm_conf.get_opposite_site(settings.sm_conf.get_active_site(cmd, site))}")
        logging.info(f"Kubernetes services managed by site-manager: {sm_dict.get_services_list_for_ok_site()}")
        logging.info(f"Kubernetes services that will be processed:  {services_to_run}")
        logging.info("---------------------------------------------------------------------")
    elif part in "tail":
        logging.info("---------------------------------------------------------------------")
        logging.info("Summary:")
        logging.info(f"services that successfully done: {list(dict.fromkeys(settings.done_services))}")
        logging.info(f"services that failed:            {settings.failed_services}")
        logging.info(f"services that ignored:           {settings.ignored_services}")
        logging.info("---------------------------------------------------------------------")


def make_ordered_services_to_process(sm_dict: SMClusterState, site, services_to_process: list = None,
                                     module = settings.default_module ) -> Tuple[list, bool, Optional[TopologicalSorter2]]:
    """ Make ordered and validated services list from all sites in sm_dict
    @returns: ordered list or empty if not possible to assemble(integrity issue), True or False  in case minor issue
        TopologicalSorter object in case success
    @todo[3]: cross site validation
    """
    def build_after_before_graph(dep_list: dict) -> TopologicalSorter2:
        """Assemble directed graph using AFTER and BEFORE dependency
        @param dep_list:[]: services list with deps in special format, see @note
        @returns: TopologicalSorter graph
        @todo: [3] multiple dependency service support
        @note:  format of input list  [{'serv2':{'after':['serv1'],'before':['serv3']}},...]
        """
        ts = TopologicalSorter2()
        for item in dep_list.keys():
            ts.add(item)
            if dep_list[item].get('after') and dep_list[item]['after'][0] in [ii for ii in dep_list.keys()]:
                ts.add(item, dep_list[item]['after'][0]) #if dep[AFTER,BEFORE] is present and exist in the dep_list - add it
            if dep_list[item].get('before') and dep_list[item]['before'][0] in [ii for ii in dep_list.keys()]:
                ts.add(dep_list[item]['before'][0], item)
        return ts

    def after_before_check(ll: dict) -> {}:
        """ Check AFTER and BEFORE dependency integrity
        @returns: dict of services if any with non exist deps , see format in @note
        @note: the return dict format {service:{'before':wrong_dep}}}
        """
        wrong_dep_list={}
        for i in ll.keys():
            if ll[i]['after'] and  ll[i]['after'][0] not in [ii for ii in ll.keys()]: #if wrong dep - collect them
                if not wrong_dep_list.get(i):
                    wrong_dep_list[i]={}
                wrong_dep_list[i]['after'] = ll[i]['after']

            if ll[i]['before'] and ll[i]['before'][0] not in [ii for ii in ll.keys()]: #if wrong dep - collect them
                if not wrong_dep_list.get(i):
                    wrong_dep_list[i]={}
                wrong_dep_list[i]['before'] = ll[i]['before']

        return wrong_dep_list

    ret = True
    integrity_error = False
    temp_dict = copy.deepcopy(sm_dict)

    # leave only services listed in service_to_process, not skipped/ignored and belong to module
    for serv in temp_dict[site]['services'].copy().keys():
        if temp_dict[site]['services'][serv].get('module',"") not in module:
            temp_dict[site]['services'].pop(serv, None)
        if services_to_process and serv not in services_to_process:
            temp_dict[site]['services'].pop(serv,None)
        if settings.ignored_services and serv in settings.ignored_services: # remove skipped/ignored
            temp_dict[site]['services'].pop(serv, None)

    # collect sorted ordered service list
    service_lists = []
    try:
        service_lists = [i for i in build_after_before_graph(temp_dict[site]['services']).static_order()]
        for service, depends in after_before_check(temp_dict[site]['services']).items():  # check deps
            for depend in depends:
                logging.warning(f"Site: {site}. Service: {service} has nonexistent "
                                f"{depend} dependency: {depends[depend]}")
                ret = False
    except CycleError as e:
        logging.error(f"Site {site} has integrity issues: %s",e)
        integrity_error = True

    if integrity_error:
        return [], False, type(None) # return error, integrity issue

    # check services equality on all sites
    ts = build_after_before_graph(temp_dict[site]['services'])
    ts.prepare()
    return service_lists, ret, ts


def print_main_table(sm_dict: SMClusterState, services_to_run, sites_name: []):
    """ Method intended to display main section of status table
    @param dict sm_dict: the results of the procedure received from the site-manager
    @param list services_to_run: the list of services that have been processed
    @param list sites_name: list of cluster names
    """
    def make_table(header, sites_name):
        """
        Method for creating the main parts of the table
        """

        pt=PrettyTable()
        pt_field_names=["Service"]

        for sites_item in sites_name:
            pt_field_names.append(f"{sites_item}")

        pt.field_names=pt_field_names
        pt.align["Service"]="l"

        # Additional header
        comment_pt_row = [""]
        separator_pt_row = ["--------------------------"]

        for sites_item in sites_name:
            comment_pt_row.append(header)
            separator_pt_row.append("------------------------------------")

        pt.add_row(comment_pt_row)
        pt.add_row(separator_pt_row)
        pt.max_width = 50
        return pt
    pt = make_table("mode | DR status | healthz | message", sites_name)
    for service_item in services_to_run:
        service_pt_row = list()
        service_pt_row.append(service_item)
        for sites_item in sites_name:
            if sm_dict[sites_item]['status'] and sm_dict[sites_item]['services'].get(service_item) and \
                    sm_dict[sites_item]['services'][service_item].get('status'):
                service_pt_row.append(
                    f"{sm_dict[sites_item]['services'][service_item]['status']['mode']} / "
                    f"{sm_dict[sites_item]['services'][service_item]['status']['status']} / "
                    f"{sm_dict[sites_item]['services'][service_item]['status']['healthz']} / "
                    f"{sm_dict[sites_item]['services'][service_item]['status']['message']}")
            else:
                service_pt_row.append("-- / -- / -- /")
        pt.add_row(service_pt_row)

    print(pt)


def parse_command_line(command_args) -> argparse.Namespace:
    """ Main argument parser
    @return:
    """
    parser = argparse.ArgumentParser(description=MAIN_HELP_SECTION,
                                     argument_default=argparse.SUPPRESS,
                                     formatter_class=argparse.RawTextHelpFormatter)

    parser.add_argument('-v', '--verbose', default=False, action='store_true', help='enable the verbosity mode')
    parser.add_argument('-c', '--config', default="", help='define the path to configuration file')
    parser.add_argument('-f', '--force', default=False, action='store_true', help='force apply DR action and ignore healthz')
    parser.add_argument('-k', '--insecure', default=False, action='store_true', help='enable self-signed certificates')
    parser.add_argument('-o', '--output', default="", help='define the filename for logging output')
    parser.add_argument('-r', '--ignore-restrictions', default=False, action='store_true', help='skip state restrictions validation')

    parser.add_argument('--run-services', default='', help='define the list of services to apply DR action, by default all services participate')
    parser.add_argument('--skip-services',  default='', help='define the list of services what will not participate in DR action')

    subparsers = parser.add_subparsers()
    subparsers.required=True

    parser_1 = subparsers.add_parser('move', help='move Active functionality to Standby site')  # DR switchover
    parser_1.add_argument('site', help=SITE_HELP_SECTION)
    parser_1.set_defaults(command='move')

    parser_2 = subparsers.add_parser('stop', help='excludes site from Active-Standby scheme')  # DR failover
    parser_2.add_argument('site', help=SITE_HELP_SECTION)
    parser_2.set_defaults(command='stop')

    parser_3 = subparsers.add_parser('return', help='return stopped Kubernetes cluster to Standby role')
    parser_3.add_argument('site', help=SITE_HELP_SECTION)
    parser_3.set_defaults(command='return')

    parser_4 = subparsers.add_parser('disable', help='stop Standby kubernetes cluster for maintenance')
    parser_4.add_argument('site', help=SITE_HELP_SECTION)
    parser_4.set_defaults(command='disable')

    parser_5 = subparsers.add_parser('active', help='set kubernetes cluster services to active mode')
    parser_5.add_argument('site', help=SITE_HELP_SECTION)
    parser_5.set_defaults(command='active')

    parser_6 = subparsers.add_parser('standby', help='set kubernetes cluster services to standby mode')
    parser_6.add_argument('site', help=SITE_HELP_SECTION)
    parser_6.set_defaults(command='standby')

    parser_7 = subparsers.add_parser('list', help='list all services from Active-Standby scheme managed by site-manager with dependencies')
    parser_7.add_argument('site', nargs='?', default="", help=SITE_HELP_SECTION)
    parser_7.set_defaults(command='list')

    parser_8 = subparsers.add_parser('status', help='show current status of clusters and all services')
    parser_8.add_argument('site', nargs='?', default="", help=SITE_HELP_SECTION)  # todo to update help
    parser_8.set_defaults(command='status')

    parser_9 = subparsers.add_parser('version', help='get current version')
    parser_9.set_defaults(command='version')

    return parser.parse_args(args=command_args)


def main(command_args=None):
    global args
    args = parse_command_line(command_args)

    # get version command
    if args.command in "version":
        with open('version', 'r') as f:
            print('SM-client %s' % f.read())
        exit(0)

    if not init_and_check_config(args):
        exit(1)

    settings.ignored_services.extend(settings.skip_services)

    if not run([i for i in settings.run_services if i not in settings.skip_services], args.command,
                args.site if hasattr(args, 'site') else False):
        exit(1)
    exit(0)


if __name__ == "__main__":
    main()
