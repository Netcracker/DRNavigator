#!/usr/bin/env python3
"""
Company:     NetCracker 
Author:      Core PaaS Group
Version:     0.6
Date:        2021-11-19
Description: Client util to manage site-manager in kubernetes clusters
"""

import argparse
import logging
import threading
import time
import yaml
import requests
import os
from requests.packages.urllib3.exceptions import InsecureRequestWarning
from prettytable import PrettyTable

#Disable warnings about self-signed certificates from requests library
requests.packages.urllib3.disable_warnings(InsecureRequestWarning)

MAIN_HELP_SECTION = """
Script to manage DR cases in kubernetes Active-Standby scheme

How to use commands:

  +------------------------------+        +------------------------------+
  |      INITIAL CONDITION       |        |        FINAL CONDITION       |
  +--------------+---------------+--------+--------------+---------------+-----+---------+
  | ACTIVE SITE  | STANDBY SITE  |  ===>  | ACTIVE SITE  | STANDBY SITE  |     | COMMAND |
  +--------------+---------------+  ===>  +--------------+---------------+     +---------+
  | ACTIVE       | STANDBY       |  ===>  | STANDBY      | ACTIVE        |  =  | move    |
  | failed       | STANDBY       |  ===>  | stopped      | ACTIVE        |  =  | stop    |
  | stopped      | ACTIVE        |  ===>  | STANDBY      | ACTIVE        |  =  | return  |
  | ACTIVE       | stopped       |  ===>  | ACTIVE       | STANDBY       |  =  | return  |
  | ACTIVE       | STANDBY       |  ===>  | ACTIVE       | stopped       |  =  | mntc    |
  +--------------+---------------+--------+--------------+---------------+-----+---------+
"""

SITE_HELP_SECTION = """define the cluster name.
This site:
  will be active in case of move 
  will be standby in case of stop
  will be standby in case of return
  will be disable to maintenance in case of mntc
"""

running_procedure = ""
running_services = []
done_services = []
ignored_services = []
failed_services = []
procedure_results = dict()

sm_dict = {}

command_list = ["stop", "move", "return", "mntc", "active", "standby", "list", "status"]

# Main argument parser 
parser = argparse.ArgumentParser(description=MAIN_HELP_SECTION,
                                 argument_default=argparse.SUPPRESS,
                                 formatter_class=argparse.RawTextHelpFormatter)

parser.add_argument('-v', '--verbose', default=False, action='store_true', help='enable the verbosity mode')
parser.add_argument('-c', '--config', default="", help='define the path to configuration file')
parser.add_argument('-f', '--force', default=False, action='store_true', help='force apply DR action and ignore healthz')
parser.add_argument('-k', '--insecure', default=False, action='store_true', help='enable self-signed certificates')
parser.add_argument('--run-services', default='', help='define the list of services to apply DR action, by default all services participate')
parser.add_argument('--skip-services',  default='', help='define the list of services what will not participate in DR action')

subparsers = parser.add_subparsers()

parser_1 = subparsers.add_parser('move', help='move Active functionality to Standby site')
parser_1.add_argument('site', help=SITE_HELP_SECTION)
parser_1.set_defaults(command='move')

parser_2 = subparsers.add_parser('stop', help='excludes site from Active-Standby scheme')
parser_2.add_argument('site', help=SITE_HELP_SECTION)
parser_2.set_defaults(command='stop')

parser_3 = subparsers.add_parser('return', help='return stopped Kubernetes cluster to Standby role')
parser_3.add_argument('site', help=SITE_HELP_SECTION)
parser_3.set_defaults(command='return')

parser_4 = subparsers.add_parser('mntc', help='stop Standby kubernetes cluster for maintenance')
parser_4.add_argument('site', help=SITE_HELP_SECTION)
parser_4.set_defaults(command='mntc')

parser_5 = subparsers.add_parser('active', help='set kubernetes cluster services to active mode')
parser_5.add_argument('site', help=SITE_HELP_SECTION)
parser_5.set_defaults(command='active')

parser_6 = subparsers.add_parser('standby', help='set kubernetes cluster services to standby mode')
parser_6.add_argument('site', help=SITE_HELP_SECTION)
parser_6.set_defaults(command='standby')

parser_7 = subparsers.add_parser('list', help='list all services from Active-Standby scheme managed by site-manager with dependencies')
parser_7.set_defaults(command='list')

parser_8 = subparsers.add_parser('status', help='show current status of clusters and all services')
parser_8.set_defaults(command='status')

parser_9 = subparsers.add_parser('daemon', help='run site-manager as a service')
parser_9.set_defaults(command='daemon')

args = parser.parse_args()

# Set verbosity for logging
if args.verbose:
    verbose_mode = True
    logging_level = logging.DEBUG
    logging_format = "%(asctime)s [%(levelname)s] %(filename)s.%(funcName)s(%(lineno)d): %(message)s"
else:
    verbose_mode = False
    logging_level = logging.INFO
    logging_format = "%(asctime)s [%(levelname)s] %(filename)s: %(message)s"

logging.basicConfig(format=logging_format, level=logging_level)

logging.debug(f"Script arguments: {args}")

# Define, check and load configuration file
conf_file = os.path.join(os.path.dirname(os.path.abspath(__file__)), "config.yaml") if args.config == "" else args.config
if not os.path.isfile(conf_file):
    logging.fatal("You should define configuration file for site-manager or copy it to config.yaml in site-manager main directory")
    exit(1)

try:
    conf_parsed = yaml.load(open(conf_file), Loader=yaml.FullLoader)
except:
    logging.fatal("Can not parse configuration file!")
    exit(1)

logging.debug(f"Parsed config: {conf_parsed}")

global SM_HTTP_SECURE
global FRONT_HTTP_AUTH

SM_HTTPS_SECURE = not args.insecure
FRONT_HTTP_AUTH = conf_parsed.get("sm-client", {}).get("http_auth", False)

SERVICE_DEFAULT_TIMEOUT = conf_parsed.get("sm-client", {}).get("service_default_timeout", 200)

# Set testing mode for all procedures
if "testing" in conf_parsed and conf_parsed["testing"].get("enabled", False) == True:
    testing_mode = True
else:
    testing_mode = False

sites_name = [ i["name"] for i in conf_parsed["sites"] ]


def send_post(url, obj, token):
    """
    Method to send POST requests to services

    :param string url: the URL to service operator
    :param dict obj: the dictionary with procedure and list of services
    """
    if token != "" and FRONT_HTTP_AUTH:
        headers = {
            "Authorization": f"Bearer {token}"
        }

    else:
        headers = {}

    logging.debug(f"REST url: {url}")
    logging.debug(f"REST data: {obj}")
    logging.debug(f"REST headers: {headers}")

    for _ in range(3):
        try:
            resp = requests.post(url, json=obj, timeout=30, headers=headers, verify=SM_HTTPS_SECURE)
            response = resp.json()
            ret_code = resp.status_code
            if ret_code == 200:
                if response.get("message", ""):
                    logging.info(f"Code: {ret_code}. Message: {response['message']}")
            if ret_code in (401, 403, 500):
                if response.get("message", ""):
                    logging.error(f"Code: {ret_code}. Message: {response['message']}")
                response["bad_response"] = ret_code
                os._exit(1)
            return response

        except requests.exceptions.SSLError:
            logging.error("SSL certificate verify failed")
            logging.error("Please use key -k or --insecure")
            os._exit(1)

        except:
            logging.debug("Wrong JSON data received")

        time.sleep(2)

    return {}


def send_get(url, token):
    """
    Method to send GET requests to services

    :param string url: the URL to service operator
    """
    if token != "" and FRONT_HTTP_AUTH:
        headers = {
            "Authorization": f"Bearer {token}"
        }

    else:
        headers = {}

    logging.debug(f"REST url: {url}")
    logging.debug(f"REST headers: {headers}")

    # Testing mode
    if testing_mode:
        return {"mode": "active", "status": "done"}

    for _ in range(3):
        try:
            resp = requests.get(url, timeout=5, headers=headers, verify=SM_HTTPS_SECURE)
            if resp.status_code in (401, 403, 500):
                logging.error(f"Problem with URL: {url}")
                logging.error(f"Code: {resp.status_code}. Message: {resp.json()['message']}")
                os._exit(1)
            return resp.json()

        except requests.exceptions.SSLError:
            logging.error("SSL certificate verify failed")
            logging.error("Please use key -k or --insecure")
            os._exit(1)

        except:
            logging.debug("Wrong JSON data received")

    return {}


def polling(service, site, timeout=SERVICE_DEFAULT_TIMEOUT):
    """
    Method to poll GET|POST requests to services

    :param string service: the name of service that will be processed
    :param string site: the name of processed site
    :param int timeout: the timeout for processing service in seconds
    """
    unknown_state = {"mode": "unknown", "status": "unknown", "healthz": "--"}
    data = dict()
    init_time = int(time.time())

    count = 0
    while int(time.time()) < init_time + int(timeout):
        count += 1

        logging.info(f"Service: {service}. Site: {site}. Polling procedure status. Iteration {count}")
        logging.info(f"Service: {service}. Site: {site}. {int(timeout) - (int(time.time()) - init_time)} seconds left until timeout")

        data = send_post(sm_dict["sites"][site]["url"],
                         {"procedure": "status", "run-services": service, "polling": True},
                         sm_dict["sites"][site]["token"])

        logging.debug(f"Service: {service}. Site: {site}. Received data: {data}")
        if "status" not in data.get("services", {}).get(service, {}) or \
           "mode" not in data.get("services", {}).get(service, {}):
            time.sleep(5)
            continue

        if data["services"][service]["status"] == "running":
            time.sleep(5)
            continue

        if data["services"][service]["mode"] == sm_dict["sites"][site]["mode"]:

            if data["services"][service]["status"] == "failed":
                return data["services"][service]

            if data["services"][service]["status"] == "done":
                break

        time.sleep(5)

    count = 0
    while int(time.time()) < init_time + int(timeout):

        count += 1

        logging.info(f"Service: {service}. Site: {site}. Polling service status. Iteration {count}")
        logging.info(f"Service: {service}. Site: {site}. {int(timeout) - (int(time.time()) - init_time)} seconds left until timeout")

        data = send_post(sm_dict["sites"][site]["url"],
                         {"procedure": "status", "run-services": service, "polling": True},
                         sm_dict["sites"][site]["token"])

        logging.debug(f"Service: {service}. Site: {site}. Received status: {data['services'][service]['healthz']}")
        if "healthz" not in data.get("services", {}).get(service, {}):
            time.sleep(5)
            continue

        if (sm_dict['sites'][site]['mode'] == "active" and data["services"][service]["healthz"] == "up") or \
                (sm_dict['sites'][site]['mode'] == "standby" and
                 data["services"][service]["healthz"] in sm_dict["services"][service]["allowedStandbyStateList"]):
            break

        if data["services"][service]["healthz"] in ("degraded", "down"):
            time.sleep(5)
            continue

        time.sleep(5)

    if data:
        if data["services"][service].get("mode", "--") == "--" or \
           data["services"][service].get("status", "--") == "--":
            return unknown_state
        return data["services"][service]
    else:
        return unknown_state


def run(service, procedure, force, no_wait=True):
    """
    Method to process one service on both kubernetes clusters

    :param string service: the name of service that will be processed
    :param string procedure: the procedure that will be processed to services
    :param string force: flag to ignore healthz of service. Can be True, true, 1
    :param string no_wait: flag to define failover and other procedures. Can be True or False
    """

    global running_services
    global done_services
    global failed_services
    global procedure_results

    def process_service(service, site, force):
        global running_services
        global done_services
        global failed_services
        if procedure == "stop" and sm_dict["sites"][site]["mode"] == "standby":
            force = True
            logging.info(f"Force key enabled for procedure 'stop' for service {service} on passivated site")

        logging.info(f"Service: {service}. Site: {site}. Check current mode")
        resp = send_post(sm_dict["sites"][site]["url"],
                         {"procedure": "status", "run-services": service},
                         sm_dict["sites"][site]["token"])
        service_status = resp["services"][service]

        if "mode" not in resp.get("services", {}).get(service, {}) or \
           resp["services"][service]["mode"] == "--" or \
           "status" not in resp.get("services", {}).get(service, {}) or \
           resp["services"][service]["status"] == "--":

            logging.warning(f"Service: {service}. Site: {site}. Service is unavailable.")
            if sm_dict["sites"][site]["need"] != "wanted":
                failed_services.append(service)

            return service_status

        # Check the current service state
        if resp["services"][service]["mode"] == sm_dict['sites'][site]['mode'] and \
           resp["services"][service]["status"] == "done":

            logging.warning(f"Service: {service}. Site: {site}. Service is already {sm_dict['sites'][site]['mode']} and has status done.")

            # Check current health status
            logging.info(f"Service: {service}. Site: {site}. Check current health status")

            if (sm_dict["sites"][site]["mode"] == "active" and resp["services"][service]["healthz"].lower() != "up") or \
               (sm_dict["sites"][site]["mode"] == "standby" and resp["services"][service]["healthz"].lower() not in sm_dict["services"][service]["allowedStandbyStateList"]):

                logging.critical(f"Service: {service}. Site: {site}. Current health status is {resp['services'][service]['healthz'].lower()}. Service failed")

                if not force:
                    if service not in failed_services:
                        failed_services.append(service)

                    return service_status
                else:
                    logging.warning(f"Service: {service}. Site: {site}. Force mode enabled. Service healthz ignored")
            else:
                logging.info(f"Service: {service}. Site: {site}. Current health status is {resp['services'][service]['healthz'].lower()}")

        else:
            logging.info(f"Service: {service}. Site: {site}. Current mode is {resp['services'][service]['mode']} and status is {resp['services'][service]['status']}")

            # Check current health status
            if procedure == "move":
                logging.info(f"Service: {service}. Site: {site}. Check current health status")

                allowed_statuses = ["up"]
                allowed_statuses.extend(sm_dict["services"][service]["allowedStandbyStateList"])
                # We should check previous state of service. In that case we check allowed_statuses for standby and "allowedStandbyStateList" for active
                if (sm_dict["sites"][site]["mode"] == "standby" and resp["services"][service]["healthz"].lower() not in allowed_statuses) or \
                   (sm_dict["sites"][site]["mode"] == "active" and resp["services"][service]["healthz"].lower() not in sm_dict["services"][service]["allowedStandbyStateList"]):

                    logging.critical(f"Service: {service}. Site: {site}. Current health status is {resp['services'][service]['healthz'].lower()}. Service failed")

                    if not force:
                        if service not in failed_services:
                            failed_services.append(service)

                        return service_status
                    else:
                        logging.warning(f"Service: {service}. Site: {site}. Force mode enabled. Service healthz ignored")
                else:
                    logging.info(f"Service: {service}. Site: {site}. Current health status is {resp['services'][service]['healthz'].lower()}")

            logging.info(f"Service: {service}. Site: {site}. Set mode {sm_dict['sites'][site]['mode']}")

            obj = {"procedure": sm_dict['sites'][site]['mode'], "run-services": service, "no-wait": no_wait, "force": force}
            resp = send_post(url=sm_dict['sites'][site]['url'], obj=obj, token=sm_dict["sites"][site]["token"])
            if resp.get("bad_response"):
                failed_services.append(service)
                return dict()

            logging.info(f"Service: {service}. Site: {site}. Start polling")
            service_status = polling(service=service,
                                     site=site,
                                     timeout=sm_dict["services"][service]['timeout'])

            if service_status["status"] == "running":
                logging.error(f"Service: {service}. Site: {site}. Procedure {procedure} is in running status still.")
                if service not in failed_services and sm_dict["sites"][site]["need"] != "wanted":
                    failed_services.append(service)
                return service_status

            elif service_status["status"] == "failed":
                logging.error(f"Service: {service}. Site: {site}. Procedure {procedure} is in failed status.")
                if service not in failed_services and sm_dict["sites"][site]["need"] != "wanted":
                    failed_services.append(service)
                return service_status

            elif service_status["status"] == "unknown":
                logging.error(f"Service: {service}. Site: {site}. Procedure {procedure} is in unknown status.")
                if service not in failed_services and sm_dict["sites"][site]["need"] != "wanted":
                    failed_services.append(service)
                return service_status

            elif service_status["status"] == "done":
                if service_status["mode"] != sm_dict['sites'][site]['mode']:
                    logging.error(f"Service: {service}. Site: {site}. Procedure {procedure} has not been applied to service.")
                    if service not in failed_services and sm_dict["sites"][site]["need"] != "wanted":
                        failed_services.append(service)
                    return service_status

                logging.info(f"Service: {service}. Site: {site}. Procedure {procedure} is in done status.")

                if (sm_dict["sites"][site]["mode"] == "active" and service_status["healthz"].lower() != "up") or \
                   (sm_dict["sites"][site]["mode"] == "standby" and service_status["healthz"].lower() not in sm_dict["services"][service]["allowedStandbyStateList"]):

                    logging.critical(f"Service: {service}. Site: {site}. Current health status is {service_status['healthz'].lower()}. Service failed")
                    if not force:
                        if service not in failed_services:
                            failed_services.append(service)
                        return service_status
                    else:
                        logging.warning(f"Service: {service}. Site: {site}. Force mode enabled. Service healthz ignored")
                else:
                    logging.info(f"Service: {service}. Site: {site}. Current health status is {service_status['healthz'].lower()}")
                    logging.info(f"Service: {service}. Site: {site}. Procedure {procedure} is finished successfully.")
        return service_status

    running_services.append(service)

    if not procedure_results.get(service, dict()):
        procedure_results[service] = dict()
    if procedure in ("active", "standby", "stop", "move", "return"):
        for seq_item in sm_dict["services"][service]["sequence"]:
            if service in failed_services:
                break
            for site_item in sm_dict["available"]:
                if sm_dict["sites"][site_item]["mode"] == seq_item:
                    procedure_results[service][site_item] = process_service(service, site_item, force)

    if procedure == 'mntc':
        for site_item in sm_dict["available"]:
            procedure_results[service][site_item] = process_service(service, site_item, force)

    running_services.remove(service)

    if service not in failed_services:
        done_services.append(service)


def create_sm_dict(sites, procedure, sites_active, sites_standby, skip_services):
    """
    Method creates dictionary of downloaded data from sitemanager CRs

    :param list sites: the list of sites to be processed
    :param string procedure: the procedure that will be processed to services
    :param list sites_active: the list of sites with mode active
    :param list sites_standby: the list of sites with mode standby
    :param list skip_services: the list of services to be skipped
    """

    if testing_mode:
        return conf_parsed["testing"].get("sm_dict", [])

    sm_dict = {}
    sm_dict["sites"] = {}
    sm_dict["available"] = []
    sm_dict["services"] = {}
    sample_dict = {}

    for site in sites:

        try:
            site_url = [ i["site-manager"] for i in conf_parsed["sites"] if i ["name"] == site ][0]
        except KeyError:
            logging.error("Check configuration file. Some of sites does not have 'site-manager' parameter")
            exit(1)

        site_token = [ i.get("token", "") for i in conf_parsed["sites"] if i ["name"] == site ][0]

        sm_dict["sites"][site] = {}
        sm_dict["sites"][site]["url"] = site_url
        sm_dict["sites"][site]["token"] = site_token

        # Set mode for site
        if site in sites_active:
            sm_dict["sites"][site]["mode"] = "active"
        elif site in sites_standby and procedure != "mntc":
            sm_dict["sites"][site]["mode"] = "standby"
        elif site in sites_standby and procedure == "mntc":
            sm_dict["sites"][site]["mode"] = "disable"

        # Define necessity to send REST request to site
        if site in sites_active and procedure in ("stop", "move", "status", "list", "active"):
            sm_dict["sites"][site]["need"] = "required"

        elif site not in sites_active and procedure in ("return", "mntc", "move", "standby"):
            sm_dict["sites"][site]["need"] = "required"

        elif site not in sites_active and procedure in ("stop", "status", "list"):
            sm_dict["sites"][site]["need"] = "wanted"

        try:
            response = send_get(site_url, sm_dict["sites"][site]["token"])
        except:
            logging.error(f"Can not download sitemanager objects from site {site}")
            continue

        if "services" in response:
            sm_dict["available"].append(site)
        else:
            logging.error(f"Site {site} does not contain any sitemanager CR")
            if not sm_dict.get("corrupted_sites", []):
                sm_dict["corrupted_sites"] = []
            sm_dict["corrupted_sites"].append(site)
            continue

        for key, value in response["services"].items():

            # Create additional dict to check all services exist on all clusters
            if key not in sample_dict:
                sample_dict[key] = [site]
            else:
                sample_dict[key].append(site)

            if key not in sm_dict["services"]:
                sm_dict["services"][key] = {}

            sm_dict["services"][key]["name"] = key
            sm_dict["services"][key]["namespace"] = value.get("namespace", "")

            sm_dict["services"][key]["after"] = value.get("after", [])
            sm_dict["services"][key]["before"] = value.get("before", [])
            sm_dict["services"][key]["sequence"] = ["standby", "active"] if value.get("sequence", []) == [] else value["sequence"]
            sm_dict["services"][key]["allowedStandbyStateList"] = value.get("allowedStandbyStateList", ["up"])

            sm_dict["services"][key]["timeout"] = value.get("timeout", SERVICE_DEFAULT_TIMEOUT)

    if len(sm_dict.get("corrupted_sites", [])) > 0:
        for site in sm_dict["corrupted_sites"]:
            logging.error(f"Site {site} is unreachable or it doesn't have any CR's")
            del sm_dict["sites"][site]
            sites.remove(site)

    wrong_service_counter = 0
    for key, value in sample_dict.items():

        if value != sites and \
           key not in skip_services and \
           procedure in ("move", "stop", "status", "list"):

            logging.error(f"Service '{key}' is not presented on sites: {[ elem for elem in sites if elem not in value]}.")
            wrong_service_counter += 1

    if wrong_service_counter != 0:
        logging.error("If you want to exclude any service, please add it to --skip-services argument")
        exit(1)

    return sm_dict


def check_dependencies(services_to_run, all_services, sm_dict):
    """
    Method to check dependencies between services that will be processed

    :param list services_to_run: the list of services generated  get_services_to_run() and that will be processed
    :param all_services: the list of all services from kubernetes clusters managed by site-manager
    :param dict sm_dict: the dictionary generated by get_sitemanagers_dict() and based on CRs from kubernetes clusters
    """

    dep_dict = {}

    logging.info(f"Services: {services_to_run}. Check for nonexistent dependencies.")
    for svc_item in services_to_run:
        depends = sm_dict["services"][svc_item]['after']
        if "stateful" in depends and len(depends) == 1:
            continue
        if not all(elem in all_services for elem in depends):
            dep_dict[svc_item] = []
            for after_item in sm_dict["services"][svc_item]['after']:
                if after_item not in all_services:
                    dep_dict[svc_item].append(after_item)

    if len(dep_dict) > 0:
        for dep_item in dep_dict:
            logging.critical(f"Service: {dep_item}. Service has nonexistent dependencies: {dep_dict[dep_item]}")

        exit(1)

    logging.info(f"Services: {services_to_run}. Services don\'t have nonexistent dependencies")


def get_all_services(sm_dict):
    """
    Method for definition of list of all services in kubernetes cluster managed by site-manager

    :param dict sm_dict: the dictionary generated by get_sitemanagers_dict() and based on CRs from kubernetes clusters
    """

    return list(set([ i for i in sm_dict["services"].keys() ]))


def get_services_to_run(run_services, skip_services, all_services):
    """
    Method for definition of list of services to be processed

    :param list run_services: the list of services that defined by parameter run-services
    :param list skip_services: the list of services that defined by parameter skip-services
    :param list all_services: the list of all services from kubernetes clusters managed by site-manager
    """

    if len(run_services) != 0:
        services_to_run = []
        for item in run_services:
            if item in all_services:
                services_to_run.append(item)
            else:
                logging.fatal(f"Service {item} does not exist in provided kubernetes clusters")
                exit(1)

    elif len(skip_services) != 0:
        services_to_run = all_services.copy()
        for item in skip_services:
            if item in all_services:
                services_to_run.remove(item)
            else:
                logging.warning(f"Service {item} from skip_services list doesn't present on cluster")

    else:
        services_to_run = all_services.copy()

    return services_to_run


def make_table(header, sites_name):
    """
    Method for creating the main parts of the table
    """

    pt = PrettyTable()
    pt_field_names = ["Service"]

    for sites_item in sites_name:
        pt_field_names.append(f"{sites_item}")

    pt.field_names = pt_field_names
    pt.align["Service"] = "l"

    # Additional header
    comment_pt_row = [""]
    separator_pt_row = ["--------------------------"]

    for sites_item in sites_name:
        comment_pt_row.append(header)
        separator_pt_row.append("--------------------------")

    pt.add_row(comment_pt_row)
    pt.add_row(separator_pt_row)

    return pt


def print_main_table(status_dict, services_to_run, sites_name):
    """
    Method intended to display section `additional` from the site-manager response, if any

    :param dict status_dict: the results of the procedure received from the site-manager
    :param list services_to_run: the list of services that have been processed
    :param list sites_name: list of cluster names
    """

    pt = make_table("mode | DR status | healthz", sites_name)
    for service_item in services_to_run:
        service_pt_row = list()
        service_pt_row.append(service_item)

        for sites_item in sites_name:
            service_pt_row.append(
                f"{status_dict[service_item][sites_item]['mode']} / {status_dict[service_item][sites_item]['status']} / {status_dict[service_item][sites_item]['healthz']}")
        pt.add_row(service_pt_row)

    pt.sortby = "Service"

    print(pt)


def print_additional_table(status_dict, services_to_run, sites_name):
    """
    Method intended to display section `additional` from the site-manager response, if any

    :param dict status_dict: the results of the procedure received from the site-manager
    :param list services_to_run: the list of services that have been processed
    :param list sites_name: list of cluster names
    """

    pt = make_table('additional', sites_name)
    is_any_additional = False

    for service_item in services_to_run:
        service_pt_row = list()
        service_pt_row.append(service_item)
        for sites_item in sites_name:
            additional = ""
            for item in status_dict[service_item][sites_item].get('additional', dict()):
                for key, value in status_dict[service_item][sites_item]["additional"][item].items():
                    additional = additional + str(key) + ": \n" + str(value) + " \n"
            if additional:
                service_pt_row.append(f"{additional}")
            else:
                for sites_item in sites_name:
                    if any(status_dict[service_item][sites_item].get('additional', dict())):
                        service_pt_row.append("--")
        if len(service_pt_row) > 1:
            pt.add_row(service_pt_row)
            is_any_additional = True

    pt.sortby = "Service"
    if is_any_additional:
        print(pt)


def main_func(procedure, site, run_services, skip_services, force):
    """
    Method for processing procedure for all sites

    :param string procedure: can be active, standby, mntc, list and status
    :param string site: the name of site that will be processed
    :param list run_services: is the list of services to be processed
    :param list skip_services: is the list of services to be skipped
    :param string force: flag to ignore healthz of services. Can be True, true, 1
    """

    global running_services
    global done_services
    global failed_services
    global ignored_services
    global running_procedure
    global sm_dict
    global procedure_results

    sites_active = []
    sites_standby = []
    sites_to_process = []

    running_procedure = procedure
    no_wait = True
    if procedure == "move":
        sites_active.append(site)
        sites_standby = [elem for elem in sites_name if elem not in sites_active]
        sites_to_process = sites_active + sites_standby
        no_wait = False

    elif procedure == "stop":
        sites_standby.append(site)
        sites_active = [elem for elem in sites_name if elem not in sites_standby]
        sites_to_process = sites_active + sites_standby

    elif procedure in ("return", "mntc"):
        sites_standby.append(site)
        sites_active = [elem for elem in sites_name if elem not in sites_standby]
        sites_to_process = sites_standby

    elif procedure == "active":
        sites_active.append(site)
        sites_standby = [elem for elem in sites_name if elem not in sites_active]
        sites_to_process = sites_active

    elif procedure == "standby":
        sites_standby.append(site)
        sites_active = [elem for elem in sites_name if elem not in sites_standby]
        sites_to_process = sites_standby

    # Create main dict with all services in sites
    sm_dict = create_sm_dict(sites_to_process, procedure, sites_active, sites_standby, skip_services)

    logging.debug(f"Compilled common services dict: {sm_dict}")

    all_services = get_all_services(sm_dict)
    services_to_run = get_services_to_run(run_services, skip_services, all_services)

    logging.info("---------------------------------------------------------------------")
    logging.info(f"Procedure:     {procedure}")
    logging.info(f"Active sites:  {sites_active}")
    logging.info(f"Standby sites: {sites_standby}")
    logging.info(f"Kubernetes services managed by site-manager: {all_services}")
    logging.info(f"Kubernetes services that will be processed:  {services_to_run}")
    logging.info("---------------------------------------------------------------------")

    # Checking for nonexistent dependencies
    check_dependencies(services_to_run, all_services, sm_dict)

    # Starting main loop to process all services
    logging.debug("Starting main loop")
    procedure_results = dict()
    after_stateful = []

    # TODO This is an exceptional case to handle internal NC specific module. To be reworked later in more general manner.
    replicator = "cluster-replicator"
    if replicator in all_services and replicator in services_to_run and procedure in ["move", "stop", "standby", "active"]:
        if procedure in ["active"]:
            done_services.append(replicator)
        else:
            sm_dict["services"][replicator]["sequence"] = ["standby"]
            run(replicator, procedure, force, no_wait)

    while not all(elem in (done_services + failed_services + ignored_services + after_stateful) for elem in all_services):

        for service_name in all_services:
            if service_name not in (done_services + running_services + failed_services + ignored_services):
                after_services = sm_dict["services"][service_name]["after"]
                if "stateful" in after_services:
                    logging.info(f"Founded service {service_name} which should be executed after stateful services")
                    after_stateful.append(service_name)
                    continue

                # Set service as failed when any of dependencies is failed
                if any(elem in failed_services for elem in after_services) and service_name not in failed_services:
                    logging.error(f"Service {service_name} marked as failed due to dependencies")
                    failed_services.append(service_name)
                    continue

                if service_name not in services_to_run:
                    ignored_services.append(service_name)

                else:
                    # Run service if it is not in running, failed or done lists
                    if all(elem in (done_services + ignored_services) for elem in after_services) or after_services == ['']:
                        thread = threading.Thread(target=run,
                                                  args=(service_name,
                                                        procedure,
                                                        force,
                                                        no_wait))
                        thread.name = f"Thread: {service_name}"
                        thread.start()

        if len(done_services) != 0:
            logging.debug('done_services = %s' % done_services)
        if len(ignored_services) != 0:
            logging.debug('ignored_services = %s' % ignored_services)
        if len(running_services) != 0:
            logging.debug('running_services = %s' % running_services)
        if len(failed_services) != 0:
            logging.debug('failed_services = %s' % failed_services)

        time.sleep(5)

    threads = list()
    for service in after_stateful:
        thread = threading.Thread(target=run,
                                  args=(service,
                                        procedure,
                                        force,
                                        no_wait))
        thread.name = f"Thread: {service}"
        threads.append(thread)
        thread.start()

    for thread in threads:
        thread.join()

    if replicator in all_services and replicator in services_to_run and procedure in ["move", "stop", "active"]:
        sm_dict["services"][replicator]["sequence"] = ["active"]
        run(replicator, procedure, force, no_wait)
        if replicator in failed_services and replicator in done_services:
            done_services.remove(replicator)
        done_services = list(set(done_services))
        failed_services = list(set(failed_services))

    for service in services_to_run:
        if not procedure_results.get(service, {}):
            procedure_results[service] = dict()
            for site in sites_to_process:
                procedure_results[service][site] = {'healthz': '--', 'mode': '--', 'status': '--'}
        else:
            for site in sites_to_process:
                if not procedure_results[service].get(site, {}):
                    procedure_results[service][site] = {'healthz': '--', 'mode': '--', 'status': '--'}

    logging.info("---------------------------------------------------------------------")
    logging.info("Summary:")
    logging.info(f"services that successfully done: {done_services}")
    logging.info(f"services that failed:            {failed_services}")
    logging.info(f"services that ignored:           {ignored_services}")
    logging.info("---------------------------------------------------------------------")

    print_additional_table(procedure_results, services_to_run, sites_to_process)
    # Clear working lists
    running_procedure = ""
    running_services = []
    done_services = []
    ignored_services = []
    failed_services = []
    after_stateful = []
    run_services = []
    skip_services = []


# Check services for running
if args.run_services != '':
    run_services = args.run_services.replace(',', ' ').replace('  ', ' ').split(' ')
else:
    run_services = []

if args.skip_services != '':
    skip_services = args.skip_services.replace(',', ' ').replace('  ', ' ').split(' ')
else:
    skip_services = []

# Process commands for script
if args.command in ("move", "stop", "return", "mntc", "active", "standby"):
    main_func(args.command, args.site, run_services, skip_services, args.force)

# Process command 'list'
elif args.command == "list":

    sites_active = sites_name[0]
    sites_standby = sites_name[1:]

    # Create main dict with all services in sites
    sm_dict = create_sm_dict(sites_name, "list", sites_active, sites_standby, skip_services)

    logging.debug(f"Compilled kubernetes CRs: {sm_dict}")

    all_services = get_all_services(sm_dict)
    services_to_run = get_services_to_run(run_services, skip_services, all_services)

    print(f"---------------------------------------------------------------------\n" +
          f"Sites managed by site-manager:               {sites_name}\n\n" +
          f"Kubernetes services managed by site-manager: {all_services}\n" +
          f"Kubernetes services that will be processed:  {services_to_run}\n" +
          f"---------------------------------------------------------------------")

# Process command 'status'
elif args.command == "status":

    site_active = sites_name[0]
    site_standby = sites_name[1:]

    # Create main dict with all services in sites
    sm_dict = create_sm_dict(sites_name, "status", site_active, site_standby, skip_services)

    logging.debug(f"Compilled kubernetes CRs: {sm_dict}")

    all_services = get_all_services(sm_dict)
    services_to_run = get_services_to_run(run_services, skip_services, all_services)

    status_dict = {}
    for service_item in services_to_run:
        status_dict[service_item] = {}

        for sites_item in sites_name:
            status_dict[service_item][sites_item] = {}
            data = send_post(url=sm_dict["sites"][sites_item]["url"], obj={"procedure": "status", "run-services": service_item}, token=sm_dict["sites"][sites_item]["token"])
            if data == {}:
                status_dict[service_item][sites_item] = {'healthz': '--', 'mode': '--', 'status': '--'}
            else:
                status_dict[service_item][sites_item] = data["services"][service_item]
        for item in sm_dict.get("corrupted_sites", []):
            status_dict[service_item][item] = {'healthz': '--', 'mode': '--', 'status': '--'}
    if sm_dict.get("corrupted_sites"):
        sites_name.extend(sm_dict["corrupted_sites"])
    logging.debug(f"status_dict: {status_dict}")

    print_main_table(status_dict, services_to_run, sites_name)

    print_additional_table(status_dict, services_to_run, sites_name)
