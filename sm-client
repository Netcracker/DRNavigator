#!/usr/bin/env python3
"""
Company:     NetCracker 
Author:      Core PaaS Group
Version:     0.6
Date:        2021-11-19
Description: Client util to manage site-manager in kubernetes clusters
"""

import argparse
import json
import logging
import ssl
import threading
import time
from collections import OrderedDict
from http import HTTPStatus
from ssl import SSLCertVerificationError

import yaml
import requests
import os


from requests.adapters import HTTPAdapter
from prettytable import PrettyTable
from typing import Tuple, Dict
from urllib3 import Retry
from urllib3.exceptions import InsecureRequestWarning

MAIN_HELP_SECTION = """
Script to manage DR cases in kubernetes Active-Standby scheme

How to use commands:

  +------------------------------+        +------------------------------+
  |      INITIAL CONDITION       |        |        FINAL CONDITION       |
  +--------------+---------------+--------+--------------+---------------+-----+---------+
  | ACTIVE SITE  | STANDBY SITE  |  ===>  | ACTIVE SITE  | STANDBY SITE  |     | COMMAND |
  +--------------+---------------+  ===>  +--------------+---------------+     +---------+
  | ACTIVE       | STANDBY       |  ===>  | STANDBY      | ACTIVE        |  =  | move    |
  | failed       | STANDBY       |  ===>  | stopped      | ACTIVE        |  =  | stop    |
  | stopped      | ACTIVE        |  ===>  | STANDBY      | ACTIVE        |  =  | return  |
  | ACTIVE       | stopped       |  ===>  | ACTIVE       | STANDBY       |  =  | return  |
  | ACTIVE       | STANDBY       |  ===>  | ACTIVE       | stopped       |  =  | mntc    |
  +--------------+---------------+--------+--------------+---------------+-----+---------+
"""

SITE_HELP_SECTION = """define the cluster name.
This site:
  will be active in case of move 
  will be standby in case of stop
  will be standby in case of return
  will be disable to maintenance in case of mntc
"""

running_procedure = ""
running_services = []
done_services = []
ignored_services = []
failed_services = []
procedure_results = dict()

sm_conf={}

conf_parsed = None
testing_mode = None
site_names = None
SERVICE_DEFAULT_TIMEOUT = None

DR_cmds = ("move", "stop", "status", "list")
site_cmds = ("active", "standby", "return", "mntc", "status", "list")

run_services = None
skip_services = None

def config_checks_init(args) -> list:
    """
    Main entry point. Provides validations, config parsing and initialization
    Returns:
        site_names
    """

    # Set verbosity for logging
    if args.verbose:
        logging_level = logging.DEBUG
        logging_format = "%(asctime)s [%(levelname)s] %(filename)s.%(funcName)s(%(lineno)d): %(message)s"
    else:
        logging_level = logging.INFO
        logging_format = "%(asctime)s [%(levelname)s] %(filename)s: %(message)s"

    logging.basicConfig(format=logging_format, level=logging_level)

    logging.debug(f"Script arguments: {args}")


    global conf_parsed
    # Define, check and load configuration file
    conf_file = os.path.join(os.path.dirname(os.path.abspath(__file__)), "config.yaml") if args.config == "" else args.config
    if not os.path.isfile(conf_file):
        logging.fatal("You should define configuration file for site-manager or copy it to config.yaml in site-manager main directory")
        exit(1)

    try:
        conf_parsed = yaml.load(open(conf_file), Loader=yaml.FullLoader)
    except:
        logging.fatal("Can not parse configuration file!")
        exit(1)

    logging.debug(f"Parsed config: {conf_parsed}")

    global SM_HTTP_SECURE
    global FRONT_HTTP_AUTH

    global SM_HTTPS_SECURE
    SM_HTTPS_SECURE = not args.insecure

    FRONT_HTTP_AUTH = conf_parsed.get("sm-client", {}).get("http_auth", False)

    global SERVICE_DEFAULT_TIMEOUT
    SERVICE_DEFAULT_TIMEOUT = conf_parsed.get("sm-client", {}).get("service_default_timeout", 200)

    global testing_mode
    # Set testing mode for all procedures
    if "testing" in conf_parsed and conf_parsed["testing"].get("enabled", False) == True:
        testing_mode = True
    else:
        testing_mode = False

    global site_names
    site_names = [i["name"] for i in conf_parsed["sites"]]
    global run_services
    # Check services for running
    if args.run_services != '':
        run_services = args.run_services.replace(',', ' ').replace('  ', ' ').split(' ')
    else:
        run_services = []
    global skip_services
    if args.skip_services != '':
        skip_services = args.skip_services.replace(',', ' ').replace('  ', ' ').split(' ')
    else:
        skip_services = []

    for site in site_names:
        try:
            site_url = [ i["site-manager"] for i in conf_parsed["sites"] if i ["name"] == site ][0]
        except KeyError:
            logging.error("Check configuration file. Some of sites does not have 'site-manager' parameter")
            exit(1)

        site_token = [ i.get("token", "") for i in conf_parsed["sites"] if i ["name"] == site ][0]
        site_cacert = [ i.get("cacert", True) for i in conf_parsed["sites"] if i ["name"] == site ][0]

        if site_cacert != True and not os.path.isfile(site_cacert):
            logging.fatal(f"You should define correct path to CA certificate for site {site}")
            exit(1)
        global sm_conf
        sm_conf[site] = {}
        sm_conf[site]["url"] = site_url
        sm_conf[site]["token"] = site_token
        sm_conf[site]["cacert"] = SM_HTTPS_SECURE if not SM_HTTPS_SECURE else site_cacert

    return True

def list_status_tmp(command, skip_services=None):
    services_to_run = {}

    # Process command 'list'
    if command == "list":

        sites_active = site_names[0]
        sites_standby = site_names[1:]

        # Create main dict with all services in sites
        sm_dict = create_sm_dict(site_names, "list", sites_active, sites_standby, skip_services)

        logging.debug(f"Compilled kubernetes CRs: {sm_dict}")

        all_services = get_all_services(sm_dict)
        #services_to_run = get_services_to_run(run_services, skip_services, all_services)

        print(f"---------------------------------------------------------------------\n" +
              f"Sites managed by site-manager:               {site_names}\n\n" +
              f"Kubernetes services managed by site-manager: {all_services}\n" +
              f"Kubernetes services that will be processed:  {services_to_run}\n" +
              f"---------------------------------------------------------------------")

    # Process command 'status'
    elif command == "status":

        site_active = site_names[0]
        site_standby = site_names[1:]

        # Create main dict with all services in sites
        sm_dict = create_sm_dict(site_names, "status", site_active, site_standby, skip_services)

        logging.debug(f"Compiled kubernetes CRs: {sm_dict}")

        all_services = get_all_services(sm_dict)
        #services_to_run = get_services_to_run(run_services, skip_services, all_services)

        status_dict = {}
        for service_item in services_to_run:
            status_dict[service_item] = {}

            for sites_item in site_names:
                status_dict[service_item][sites_item] = {}
                try:
                    data_t,_ = io_http_json_request(url=sm_dict["sites"][sites_item]["url"],
                                                  token=sm_dict["sites"][sites_item]["token"],
                                                  verify=sm_dict["sites"][sites_item]["cacert"],
                                                  http_body={"procedure": "status", "run-services": service_item})
                except requests.exceptions.SSLError:
                    data_t = {} # in case site is Down except balancers, getting SSL exception
                data=data_t
                if data == {}:
                    status_dict[service_item][sites_item] = {'healthz': '--', 'mode': '--', 'status': '--'}
                else:
                    status_dict[service_item][sites_item] = data["services"][service_item]

            for item in sm_dict.get("corrupted_sites", []):
                status_dict[service_item][item] = {'healthz': '--', 'mode': '--', 'status': '--'}
        if sm_dict.get("corrupted_sites"):
            site_names.extend(sm_dict["corrupted_sites"])
        logging.debug(f"status_dict: {status_dict}")

        print_main_table(status_dict, services_to_run, site_names)

        print_additional_table(status_dict, services_to_run, site_names)

def main(sm_conf, services="", cmd=""):
    sm_dict = {"sites":{}}

    for site in sm_conf.keys():
        sm_dict["sites"][site]={}
        sm_dict["sites"][site]["available"] = False
        sm_dict["sites"][site]["corrupted"] = False

        response, code = process_service(site,"site-manager","status")
        if "services" in response and code:
            sm_dict["sites"][site]["available"]=True
        else:
            logging.error(f"Site {site} does not return valid responce. Error code:", code)
            if not sm_dict.get("corrupted_sites", []):
                sm_dict["sites"][site]["corrupted"] = True
            continue

        sm_dict["sites"][site].update(response)
    print(json.dumps(sm_dict))
    return

    # assemble ordered service list keeping in services list specified in cli
    service_dep_ordered = make_ordered_services(sm_dict["sites"], services)

    # raw_site_services_list validation to satisfy cmd
    if not validate_cmd(raw_site_services_list, service_dep_ordered, cmd):
        exit(False)

    if cmd in DR_cmds and not site:  # DR command, both sites
        # handle each DR command
        if cmd in ("list", "status"):
            print_status(service_dep_ordered, cmd)
        elif cmd in ("move", "stop"):
            for serv in service_dep_ordered:
                for site, mode in get_sequence(raw_site_services_list[serv]):  # run in Thread
                    process_service(site, serv, mode)
            polling()
    elif cmd in site_cmds and site:  # per site command
        if cmd in ("return"):
            for serv in service_dep_ordered:  # run in Thread
                process_service(site, serv, "standby")
        elif cmd in ("mntc"):
            for serv in service_dep_ordered:  # run in Thread
                process_service(site, serv, "mntc")
        else:
            for serv in service_dep_ordered:  # run in Thread
                process_service(site, serv, cmd)
        polling()


def process_service(site, service, site_cmd: str, no_wait=False, force=False) -> Tuple[Dict, bool]:
    """
    Method to process the service with specific SM cmd
    """
    global sm_conf
    if site_cmd in ["status","list"]:  # RO operations
        body = "" if service == "site-manager" else {"procedure": "status", "run-services": [service]}
    elif site_cmd in ["active", "standby", "return", "mntc"]:
        if site_cmd == "mntc":
            site_cmd = "disable"
        elif site_cmd == "return":
            site_cmd = "standby"
        body = {"procedure": site_cmd, "run-services": [service], "no-wait": no_wait, "force": force}

    response, return_code = io_http_json_request(sm_conf[site]["url"],
                                               sm_conf[site]["token"],
                                               sm_conf[site]["cacert"],
                                               body)
    #TODO: ERROR handling should be here SSL, timeout and so on
    return response,True if return_code == HTTPStatus.OK else return_code


def print_status(site_services_list, cmd):
    pass

def get_sequence(param):
    pass

raw_site_services_list = {}
service_dep_ordered = OrderedDict({})


def make_ordered_services(sm_dict,services_to_process=[]):
    """
    TODO validate same services on both sides
        before , after params are the same and EXISTS
        leave only service presented on all sites
    """

    def after_sort(ll: list):
        """
        TODO list consistency validation
         before procedure support
         multiple dependency service support
        """
        sorted_list = [ list(i.keys())[ 0 ] for i in ll ]  # make a list to be sorted
        # print(sorted_list)
        for i in ll:
            if i[ list(i.keys())[ 0 ] ][ 'after' ] and \
                    i[ list(i.keys())[ 0 ] ][ 'after' ][ 0 ] in sorted_list: # if after not empty put i item AFTER dependant item
                sorted_list.insert(sorted_list.index(i[ list(i.keys())[ 0 ] ][ 'after' ][ 0 ]) + 1,
                                   sorted_list.pop(sorted_list.index(list(i.keys())[ 0 ])))
        return sorted_list

    temp_dict = sm_dict.copy()

    # leave only service listed in service_to_process
    for site in temp_dict[ 'sites' ]:
        for serv in temp_dict[ 'sites' ][ site ][ 'services' ].copy().keys():
            if services_to_process and serv not in services_to_process:
                temp_dict['sites'][site]['services'].pop(serv,None)


    #collect sorted ordered service list from both sites
    service_lists = {}
    for site in temp_dict['sites']:
        service_lists[site] =  after_sort([ {serv:{'after':value['after']} } for serv,value in
                            temp_dict['sites'][site]['services'].items() ])

    # compare service lists
    equal_list = True
    for i in range(len(service_lists.keys()) - 1):
        if list(service_lists.values())[i] != list(service_lists.values())[i+1]:
            equal_list = False

    if equal_list:
        return list(service_lists.values())[0]
    else: #TODO to rework intersect in general manner(several sites support) with comprehensive warning
        print("The service lists are different on sites:", \
              list(set(set(list(service_lists.values())[1]).
                       difference(set(list(service_lists.values())[0])))))
        return list(set(set(list(service_lists.values())[1]).
                        intersection(set(list(service_lists.values())[0]))))




def validate_cmd(raw_site_services_list, service_dep_ordered, cmd):
    pass

def io_http_json_request(url, token="", verify=True, http_body={}, retry=3) -> Tuple[Dict, int]:
    """
    Method to send GET/POST requests to service
    :param string url: the URL to service operator
    :param token: Bearer toke
    :param verify: Server side SSL verification
    :param retry: the number of retries
    :param http_body: the dictionary with procedure and list of services
    :returns:
    :Dict not empty json body in case Ok
    :HTTP_CODE or
    :False in case not http request issue
    :IO SSL codes ssl.SSLErrorNumber.SSL_ERROR_SSL SSLErrorNumber.SSL_ERROR_EOF
    """
    if(os.getenv("DEBUG")):
        # Disable warnings about self-signed certificates from requests library
        requests.packages.urllib3.disable_warnings(InsecureRequestWarning)

    if token != "" and FRONT_HTTP_AUTH:
        headers = {"Authorization": f"Bearer {token}"}
    else:
        headers = {}

    logging.debug(f"REST url: {url}")
    logging.debug(f"REST data: {http_body}")
    logging.debug(f"REST headers: {headers}")

    session = requests.Session()
    retries = Retry(total=retry)
    session.mount('https://', HTTPAdapter(max_retries=retries))
    session.mount('http://', HTTPAdapter(max_retries=retries))

    logging.getLogger("urllib3").setLevel(logging.CRITICAL)

    try:
        if any(http_body):
            resp = session.post(url, json=http_body, timeout=30, headers=headers, verify=verify)
        else:
            resp = session.get(url, timeout=5, headers=headers, verify=verify)

        return resp.json() if resp.json() else {},resp.status_code # return ANY content with HTTP code

    except requests.exceptions.SSLError as e:
        logging.error("SSL certificate verify failed")
        logging.error("Please use key -k or --insecure")
        #TODO in more accurate manner error handling manner
        if "SSLCertVerificationError" in str(e.args): ## SSL Verification fails ; SSLCertVerificationError(1, '[SSL: CERTIFICATE_VERIFY_FAILED] certificate verify failed: unable to get local issuer certificate (_ssl.c:1125)')
            return {}, ssl.SSLErrorNumber.SSL_ERROR_SSL.__int__() # - 1
        elif "SSLEOFError" in str(e.args): # SSL connect error, SSL resource is not accessible vi ha-proxy  ; SSLEOFError(8, 'EOF occurred in violation of protocol (_ssl.c:1091)')
            #TODO need a test for this case
            return {}, ssl.SSLErrorNumber.SSL_ERROR_EOF.__int__() # - 8
    except requests.exceptions.JSONDecodeError:
        logging.error("Wrong JSON data received")
    except requests.exceptions.RequestException as e:
        logging.error("General request error %s",e.__doc__)
    except Exception as e :
        logging.error("General error %s",e.__doc__)

    return {}, False

def polling(service, site, timeout=SERVICE_DEFAULT_TIMEOUT):
    """
    Method to poll GET|POST requests to services

    :param string service: the name of service that will be processed
    :param string site: the name of processed site
    :param int timeout: the timeout for processing service in seconds
    """
    unknown_state = {"mode": "unknown", "status": "unknown", "healthz": "--"}
    data = dict()
    init_time = int(time.time())

    count = 0
    while int(time.time()) < init_time + int(timeout):
        count += 1

        logging.info(f"Service: {service}. Site: {site}. Polling procedure status. Iteration {count}")
        logging.info(f"Service: {service}. Site: {site}. {int(timeout) - (int(time.time()) - init_time)} seconds left until timeout")

        data,_ = io_http_json_request(sm_conf["sites"][site]["url"],
                         sm_conf["sites"][site]["token"],
                         sm_conf["sites"][site]["cacert"],
                         {"procedure": "status", "run-services": service, "polling": True})

        logging.debug(f"Service: {service}. Site: {site}. Received data: {data}")
        if "status" not in data.get("services", {}).get(service, {}) or \
           "mode" not in data.get("services", {}).get(service, {}):
            time.sleep(5)
            continue

        if data["services"][service]["status"] == "running":
            time.sleep(5)
            continue

        if data["services"][service]["mode"] == sm_dict["sites"][site]["mode"]:

            if data["services"][service]["status"] == "failed":
                return data["services"][service]

            if data["services"][service]["status"] == "done":
                break

        time.sleep(5)

    count = 0
    while int(time.time()) < init_time + int(timeout):

        count += 1

        logging.info(f"Service: {service}. Site: {site}. Polling service status. Iteration {count}")
        logging.info(f"Service: {service}. Site: {site}. {int(timeout) - (int(time.time()) - init_time)} seconds left until timeout")

        data,_ = io_http_json_request(sm_dict["sites"][site]["url"],
                         sm_dict["sites"][site]["token"],
                         sm_dict["sites"][site]["cacert"],
                         {"procedure": "status", "run-services": service, "polling": True})

        logging.debug(f"Service: {service}. Site: {site}. Received status: {data['services'][service]['healthz']}")
        if "healthz" not in data.get("services", {}).get(service, {}):
            time.sleep(5)
            continue

        if (sm_dict['sites'][site]['mode'] == "active" and data["services"][service]["healthz"] == "up") or \
                (sm_dict['sites'][site]['mode'] == "standby" and
                 data["services"][service]["healthz"] in sm_dict["services"][service]["allowedStandbyStateList"]):
            break

        if data["services"][service]["healthz"] in ("degraded", "down"):
            time.sleep(5)
            continue

        time.sleep(5)

    if data:
        if data["services"][service].get("mode", "--") == "--" or \
           data["services"][service].get("status", "--") == "--":
            return unknown_state
        return data["services"][service]
    else:
        return unknown_state

def run(service, procedure, force, no_wait=True):
    """
    Method to process one service on both kubernetes clusters

    :param string service: the name of service that will be processed
    :param string procedure: the procedure that will be processed to services
    :param string force: flag to ignore healthz of service. Can be True, true, 1
    :param string no_wait: flag to define failover and other procedures. Can be True or False
    """

    global running_services
    global done_services
    global failed_services
    global procedure_results

    def process_service(service, site, force):
        global running_services
        global done_services
        global failed_services
        if procedure == "stop" and sm_dict["sites"][site]["mode"] == "standby":
            force = True
            logging.info(f"Force key enabled for procedure 'stop' for service {service} on passivated site")

        logging.info(f"Service: {service}. Site: {site}. Check current mode")
        resp,_ = io_http_json_request(sm_dict["sites"][site]["url"],
                         sm_dict["sites"][site]["token"],
                         sm_dict["sites"][site]["cacert"],
                         {"procedure": "status", "run-services": service},)
        service_status = resp["services"][service]

        if "mode" not in resp.get("services", {}).get(service, {}) or \
           resp["services"][service]["mode"] == "--" or \
           "status" not in resp.get("services", {}).get(service, {}) or \
           resp["services"][service]["status"] == "--":

            logging.warning(f"Service: {service}. Site: {site}. Service is unavailable.")
            if sm_dict["sites"][site]["need"] != "wanted":
                failed_services.append(service)

            return service_status

        # Check the current service state
        if resp["services"][service]["mode"] == sm_dict['sites'][site]['mode'] and \
           resp["services"][service]["status"] == "done":

            logging.warning(f"Service: {service}. Site: {site}. Service is already {sm_dict['sites'][site]['mode']} and has status done.")

            # Check current health status
            logging.info(f"Service: {service}. Site: {site}. Check current health status")

            if (sm_dict["sites"][site]["mode"] == "active" and resp["services"][service]["healthz"].lower() != "up") or \
               (sm_dict["sites"][site]["mode"] == "standby" and resp["services"][service]["healthz"].lower() not in sm_dict["services"][service]["allowedStandbyStateList"]):

                logging.critical(f"Service: {service}. Site: {site}. Current health status is {resp['services'][service]['healthz'].lower()}. Service failed")

                if not force:
                    if service not in failed_services:
                        failed_services.append(service)

                    return service_status
                else:
                    logging.warning(f"Service: {service}. Site: {site}. Force mode enabled. Service healthz ignored")
            else:
                logging.info(f"Service: {service}. Site: {site}. Current health status is {resp['services'][service]['healthz'].lower()}")

        else:
            logging.info(f"Service: {service}. Site: {site}. Current mode is {resp['services'][service]['mode']} and status is {resp['services'][service]['status']}")

            # Check current health status
            if procedure == "move":
                logging.info(f"Service: {service}. Site: {site}. Check current health status")

                allowed_statuses = ["up"]
                allowed_statuses.extend(sm_dict["services"][service]["allowedStandbyStateList"])
                # We should check previous state of service. In that case we check allowed_statuses for standby and "allowedStandbyStateList" for active
                if (sm_dict["sites"][site]["mode"] == "standby" and resp["services"][service]["healthz"].lower() not in allowed_statuses) or \
                   (sm_dict["sites"][site]["mode"] == "active" and resp["services"][service]["healthz"].lower() not in sm_dict["services"][service]["allowedStandbyStateList"]):

                    logging.critical(f"Service: {service}. Site: {site}. Current health status is {resp['services'][service]['healthz'].lower()}. Service failed")

                    if not force:
                        if service not in failed_services:
                            failed_services.append(service)

                        return service_status
                    else:
                        logging.warning(f"Service: {service}. Site: {site}. Force mode enabled. Service healthz ignored")
                else:
                    logging.info(f"Service: {service}. Site: {site}. Current health status is {resp['services'][service]['healthz'].lower()}")

            logging.info(f"Service: {service}. Site: {site}. Set mode {sm_dict['sites'][site]['mode']}")

            obj = {"procedure": sm_dict['sites'][site]['mode'], "run-services": service, "no-wait": no_wait, "force": force}
            resp,_ = io_http_json_request(url=sm_dict['sites'][site]['url'],
                                          token=sm_dict["sites"][site]["token"],
                                          verify=sm_dict["sites"][site]["cacert"],
                                          http_body = obj)
            if resp.get("bad_response"):
                failed_services.append(service)
                return dict()

            logging.info(f"Service: {service}. Site: {site}. Start polling")
            service_status = polling(service=service,
                                     site=site,
                                     timeout=sm_dict["services"][service]['timeout'])

            if service_status["status"] == "running":
                logging.error(f"Service: {service}. Site: {site}. Procedure {procedure} is in running status still.")
                if service not in failed_services and sm_dict["sites"][site]["need"] != "wanted":
                    failed_services.append(service)
                return service_status

            elif service_status["status"] == "failed":
                logging.error(f"Service: {service}. Site: {site}. Procedure {procedure} is in failed status.")
                if service not in failed_services and sm_dict["sites"][site]["need"] != "wanted":
                    failed_services.append(service)
                return service_status

            elif service_status["status"] == "unknown":
                logging.error(f"Service: {service}. Site: {site}. Procedure {procedure} is in unknown status.")
                if service not in failed_services and sm_dict["sites"][site]["need"] != "wanted":
                    failed_services.append(service)
                return service_status

            elif service_status["status"] == "done":
                if service_status["mode"] != sm_dict['sites'][site]['mode']:
                    logging.error(f"Service: {service}. Site: {site}. Procedure {procedure} has not been applied to service.")
                    if service not in failed_services and sm_dict["sites"][site]["need"] != "wanted":
                        failed_services.append(service)
                    return service_status

                logging.info(f"Service: {service}. Site: {site}. Procedure {procedure} is in done status.")

                if (sm_dict["sites"][site]["mode"] == "active" and service_status["healthz"].lower() != "up") or \
                   (sm_dict["sites"][site]["mode"] == "standby" and service_status["healthz"].lower() not in sm_dict["services"][service]["allowedStandbyStateList"]):

                    logging.critical(f"Service: {service}. Site: {site}. Current health status is {service_status['healthz'].lower()}. Service failed")
                    if not force:
                        if service not in failed_services:
                            failed_services.append(service)
                        return service_status
                    else:
                        logging.warning(f"Service: {service}. Site: {site}. Force mode enabled. Service healthz ignored")
                else:
                    logging.info(f"Service: {service}. Site: {site}. Current health status is {service_status['healthz'].lower()}")
                    logging.info(f"Service: {service}. Site: {site}. Procedure {procedure} is finished successfully.")
        return service_status

    running_services.append(service)

    if not procedure_results.get(service, dict()):
        procedure_results[service] = dict()
    if procedure in ("active", "standby", "stop", "move", "return"):
        for seq_item in sm_dict["services"][service]["sequence"]:
            if service in failed_services:
                break
            for site_item in sm_dict["available"]:
                if sm_dict["sites"][site_item]["mode"] == seq_item:
                    procedure_results[service][site_item] = process_service(service, site_item, force)
    elif procedure == 'mntc':
        for site_item in sm_dict["available"]:
            procedure_results[service][site_item] = process_service(service, site_item, force)

    running_services.remove(service)

    if service not in failed_services:
        done_services.append(service)

def check_dependencies(services_to_run, all_services, sm_dict):
    """
    Method to check dependencies between services that will be processed

    :param list services_to_run: the list of services generated  get_services_to_run() and that will be processed
    :param all_services: the list of all services from kubernetes clusters managed by site-manager
    :param dict sm_dict: the dictionary generated by get_sitemanagers_dict() and based on CRs from kubernetes clusters
    """

    dep_dict = {}

    logging.info(f"Services: {services_to_run}. Check for nonexistent dependencies.")
    for svc_item in services_to_run:
        depends = sm_dict["services"][svc_item]['after']
        if "stateful" in depends and len(depends) == 1:
            continue
        if not all(elem in all_services for elem in depends):
            dep_dict[svc_item] = []
            for after_item in sm_dict["services"][svc_item]['after']:
                if after_item not in all_services:
                    dep_dict[svc_item].append(after_item)

    for dep_item in dep_dict:
        logging.critical(f"Service: {dep_item}. Service has nonexistent dependencies: {dep_dict[dep_item]}")

    if len(dep_dict) and (
            running_procedure != "stop" and # do not exit in case failover
            not any( site['need'] == 'wanted' for site in sm_dict["sites"].values())): # do not exit in case failover,list,status
        exit(1)

    logging.info(f"Services: {services_to_run}. Services don\'t have nonexistent dependencies")


def get_all_services(sm_dict):
    """
    Method for definition of list of all services in kubernetes cluster managed by site-manager

    :param dict sm_dict: the dictionary generated by get_sitemanagers_dict() and based on CRs from kubernetes clusters
    """

    return list(set([ i for i in sm_dict["services"].keys() ]))


def get_services_to_run(run_services, skip_services, all_services):
    """
    Method for definition of list of services to be processed

    :param list run_services: the list of services that defined by parameter run-services
    :param list skip_services: the list of services that defined by parameter skip-services
    :param list all_services: the list of all services from kubernetes clusters managed by site-manager
    """

    if len(run_services) != 0:
        services_to_run = []
        for item in run_services:
            if item in all_services:
                services_to_run.append(item)
            else:
                logging.fatal(f"Service {item} does not exist in provided kubernetes clusters")
                exit(1)

    elif len(skip_services) != 0:
        services_to_run = all_services.copy()
        for item in skip_services:
            if item in all_services:
                services_to_run.remove(item)
            else:
                logging.warning(f"Service {item} from skip_services list doesn't present on cluster")

    else:
        services_to_run = all_services.copy()

    return services_to_run


def make_table(header, sites_name):
    """
    Method for creating the main parts of the table
    """

    pt = PrettyTable()
    pt_field_names = ["Service"]

    for sites_item in sites_name:
        pt_field_names.append(f"{sites_item}")

    pt.field_names = pt_field_names
    pt.align["Service"] = "l"

    # Additional header
    comment_pt_row = [""]
    separator_pt_row = ["--------------------------"]

    for sites_item in sites_name:
        comment_pt_row.append(header)
        separator_pt_row.append("--------------------------")

    pt.add_row(comment_pt_row)
    pt.add_row(separator_pt_row)

    return pt


def print_main_table(status_dict, services_to_run, sites_name):
    """
    Method intended to display section `additional` from the site-manager response, if any

    :param dict status_dict: the results of the procedure received from the site-manager
    :param list services_to_run: the list of services that have been processed
    :param list sites_name: list of cluster names
    """

    pt = make_table("mode | DR status | healthz", sites_name)
    for service_item in services_to_run:
        service_pt_row = list()
        service_pt_row.append(service_item)

        for sites_item in sites_name:
            service_pt_row.append(
                f"{status_dict[service_item][sites_item]['mode']} / {status_dict[service_item][sites_item]['status']} / {status_dict[service_item][sites_item]['healthz']}")
        pt.add_row(service_pt_row)

    pt.sortby = "Service"

    print(pt)


def print_additional_table(status_dict, services_to_run, sites_name):
    """
    Method intended to display section `additional` from the site-manager response, if any

    :param dict status_dict: the results of the procedure received from the site-manager
    :param list services_to_run: the list of services that have been processed
    :param list sites_name: list of cluster names
    """

    pt = make_table('additional', sites_name)
    is_any_additional = False

    for service_item in services_to_run:
        service_pt_row = list()
        service_pt_row.append(service_item)
        for sites_item in sites_name:
            additional = ""
            for item in status_dict[service_item][sites_item].get('additional', dict()):
                for key, value in status_dict[service_item][sites_item]["additional"][item].items():
                    additional = additional + str(key) + ": \n" + str(value) + " \n"
            if additional:
                service_pt_row.append(f"{additional}")
            else:
                for sites_item in sites_name:
                    if any(status_dict[service_item][sites_item].get('additional', dict())):
                        service_pt_row.append("--")
        if len(service_pt_row) > 1:
            pt.add_row(service_pt_row)
            is_any_additional = True

    pt.sortby = "Service"
    if is_any_additional:
        print(pt)


def main_func(procedure, site, run_services, skip_services, force):
    """
    Method for processing procedure for all sites

    :param string procedure: can be active, standby, mntc, list and status
    :param string site: the name of site that will be processed
    :param list run_services: is the list of services to be processed
    :param list skip_services: is the list of services to be skipped
    :param string force: flag to ignore healthz of services. Can be True, true, 1
    """

    global running_services
    global done_services
    global failed_services
    global ignored_services
    global running_procedure
    global sm_dict
    global procedure_results

    sites_active = []
    sites_standby = []
    sites_to_process = []

    running_procedure = procedure
    no_wait = True
    if procedure == "move":  # DR e2e operation on both sites
        sites_active.append(site)
        sites_standby = [elem for elem in site_names if elem not in sites_active]
        sites_to_process = sites_active + sites_standby
        no_wait = False
    elif procedure == "stop":
        sites_standby.append(site)
        sites_active = [elem for elem in site_names if elem not in sites_standby]
        sites_to_process = sites_active + sites_standby

    if procedure in ("return", "mntc"):  # DR operation on single site
        sites_standby.append(site)
        sites_active = [elem for elem in site_names if elem not in sites_standby]
        sites_to_process = sites_standby
    elif procedure == "active":
        sites_active.append(site)
        sites_standby = [elem for elem in site_names if elem not in sites_active]
        sites_to_process = sites_active
    elif procedure == "standby":
        sites_standby.append(site)
        sites_active = [elem for elem in site_names if elem not in sites_standby]
        sites_to_process = sites_standby

    # Create main dict with all services in sites
    sm_dict = create_sm_dict(sites_to_process, procedure, sites_active, sites_standby, skip_services)

    logging.debug(f"Compiled common services dict: {sm_dict}")

    all_services = get_all_services(sm_dict)
    services_to_run = get_services_to_run(run_services, skip_services, all_services)

    logging.info("---------------------------------------------------------------------")
    logging.info(f"Procedure:     {procedure}")
    logging.info(f"Active sites:  {sites_active}")
    logging.info(f"Standby sites: {sites_standby}")
    logging.info(f"Kubernetes services managed by site-manager: {all_services}")
    logging.info(f"Kubernetes services that will be processed:  {services_to_run}")
    logging.info("---------------------------------------------------------------------")

    # Checking for nonexistent dependencies
    check_dependencies(services_to_run, all_services, sm_dict)

    # Starting main loop to process all services
    logging.debug("Starting main loop")
    procedure_results = dict()
    after_stateful = []

    # TODO This is an exceptional case to handle internal NC specific module. To be reworked later in more general manner.
    replicator = "cluster-replicator"
    if replicator in all_services and replicator in services_to_run and procedure in ["move", "stop", "standby", "active"]:
        if procedure in ["active"]:
            done_services.append(replicator)
        else:
            sm_dict["services"][replicator]["sequence"] = ["standby"]
            run(replicator, procedure, force, no_wait)

    while not all(elem in (done_services + failed_services + ignored_services + after_stateful) for elem in all_services):

        for service_name in all_services:
            if service_name not in (done_services + running_services + failed_services + ignored_services):
                after_services = sm_dict["services"][service_name]["after"]
                if "stateful" in after_services:
                    logging.info(f"Founded service {service_name} which should be executed after stateful services")
                    after_stateful.append(service_name)
                    continue

                # Set service as failed when any of dependencies is failed
                if any(elem in failed_services for elem in after_services) and service_name not in failed_services:
                    logging.error(f"Service {service_name} marked as failed due to dependencies")
                    failed_services.append(service_name)
                    continue

                if service_name not in services_to_run:
                    ignored_services.append(service_name)
                else:
                    # Run service if it is not in running, failed or done lists
                    if all(elem in (done_services + ignored_services) for elem in after_services) or after_services == ['']:
                        thread = threading.Thread(target=run,
                                                  args=(service_name,
                                                        procedure,
                                                        force,
                                                        no_wait))
                        thread.name = f"Thread: {service_name}"
                        thread.start()

        if len(done_services) != 0:
            logging.debug('done_services = %s' % done_services)
        if len(ignored_services) != 0:
            logging.debug('ignored_services = %s' % ignored_services)
        if len(running_services) != 0:
            logging.debug('running_services = %s' % running_services)
        if len(failed_services) != 0:
            logging.debug('failed_services = %s' % failed_services)

        time.sleep(5)

    threads = list()
    for service in after_stateful:
        thread = threading.Thread(target=run,
                                  args=(service,
                                        procedure,
                                        force,
                                        no_wait))
        thread.name = f"Thread: {service}"
        threads.append(thread)
        thread.start()

    for thread in threads:
        thread.join()

    if replicator in all_services and replicator in services_to_run and procedure in ["move", "stop", "active"]:
        sm_dict["services"][replicator]["sequence"] = ["active"]
        run(replicator, procedure, force, no_wait)
        if replicator in failed_services and replicator in done_services:
            done_services.remove(replicator)
        done_services = list(set(done_services))
        failed_services = list(set(failed_services))

    for service in services_to_run:
        if not procedure_results.get(service, {}):
            procedure_results[service] = dict()
            for site in sites_to_process:
                procedure_results[service][site] = {'healthz': '--', 'mode': '--', 'status': '--'}
        else:
            for site in sites_to_process:
                if not procedure_results[service].get(site, {}):
                    procedure_results[service][site] = {'healthz': '--', 'mode': '--', 'status': '--'}

    logging.info("---------------------------------------------------------------------")
    logging.info("Summary:")
    logging.info(f"services that successfully done: {done_services}")
    logging.info(f"services that failed:            {failed_services}")
    logging.info(f"services that ignored:           {ignored_services}")
    logging.info("---------------------------------------------------------------------")

    print_additional_table(procedure_results, services_to_run, sites_to_process)

    if len(failed_services) != 0:
        logging.fatal(f"Some services finished {procedure} with failed status")
        exit(1)

    # Clear working lists
    running_procedure = ""
    running_services = []
    done_services = []
    ignored_services = []
    failed_services = []

if __name__ == "__main__":
    # Main argument parser
    parser = argparse.ArgumentParser(description=MAIN_HELP_SECTION,
                                     argument_default=argparse.SUPPRESS,
                                     formatter_class=argparse.RawTextHelpFormatter)

    parser.add_argument('-v', '--verbose', default=False, action='store_true', help='enable the verbosity mode')
    parser.add_argument('-c', '--config', default="", help='define the path to configuration file')
    parser.add_argument('-f', '--force', default=False, action='store_true', help='force apply DR action and ignore healthz')
    parser.add_argument('-k', '--insecure', default=False, action='store_true', help='enable self-signed certificates')
    parser.add_argument('--run-services', default='', help='define the list of services to apply DR action, by default all services participate')
    parser.add_argument('--skip-services',  default='', help='define the list of services what will not participate in DR action')

    subparsers = parser.add_subparsers()

    parser_1 = subparsers.add_parser('move', help='move Active functionality to Standby site')  # DR switchover
    parser_1.add_argument('site', help=SITE_HELP_SECTION)
    parser_1.set_defaults(command='move')

    parser_2 = subparsers.add_parser('stop', help='excludes site from Active-Standby scheme')  # DR failover
    parser_2.add_argument('site', help=SITE_HELP_SECTION)
    parser_2.set_defaults(command='stop')

    parser_3 = subparsers.add_parser('return', help='return stopped Kubernetes cluster to Standby role')
    parser_3.add_argument('site', help=SITE_HELP_SECTION)
    parser_3.set_defaults(command='return')

    parser_4 = subparsers.add_parser('mntc', help='stop Standby kubernetes cluster for maintenance')
    parser_4.add_argument('site', help=SITE_HELP_SECTION)
    parser_4.set_defaults(command='mntc')

    parser_5 = subparsers.add_parser('active', help='set kubernetes cluster services to active mode')
    parser_5.add_argument('site', help=SITE_HELP_SECTION)
    parser_5.set_defaults(command='active')

    parser_6 = subparsers.add_parser('standby', help='set kubernetes cluster services to standby mode')
    parser_6.add_argument('site', help=SITE_HELP_SECTION)
    parser_6.set_defaults(command='standby')

    parser_7 = subparsers.add_parser('list', help='list all services from Active-Standby scheme managed by site-manager with dependencies')
    parser_7.set_defaults(command='list')

    parser_8 = subparsers.add_parser('status', help='show current status of clusters and all services')
    parser_8.set_defaults(command='status')

    parser_9 = subparsers.add_parser('daemon', help='run site-manager as a service')
    parser_9.set_defaults(command='daemon')

    args = parser.parse_args()

    config_checks_init(args)
    main(sm_conf,[i for i in run_services if i not in skip_services])