#!/usr/bin/env python3.9
"""
Company:     NetCracker 
Author:      Core PaaS Group
Version:     0.7
Date:        2021-11-19
Description: Client util to communicate with site-manager in kubernetes based clusters
@todo[3]
    split current single source into modules,classes ; share common code with sm
    logging into file
    make smclient delivery as single binary, using pyinstaller ???
    cli json output
    SM specific data structures : sm_dict; service response: 50%
"""

import argparse
import copy
import logging
import pathlib
import ssl
import sys
import threading
import time
from graphlib import TopologicalSorter, CycleError
from http import HTTPStatus
from queue import Queue

import yaml
import os

from prettytable import PrettyTable
from typing import Tuple, Dict, Optional


from utils import  io_make_http_json_request
MAIN_HELP_SECTION = """
Script to manage DR cases in kubernetes Active-Standby scheme

How to use commands:

  +------------------------------+        +------------------------------+
  |      INITIAL CONDITION       |        |        FINAL CONDITION       |
  +--------------+---------------+--------+--------------+---------------+-----+---------+
  | ACTIVE SITE  | STANDBY SITE  |  ===>  | ACTIVE SITE  | STANDBY SITE  |     | COMMAND |
  +--------------+---------------+  ===>  +--------------+---------------+     +---------+
  | ACTIVE       | STANDBY       |  ===>  | STANDBY      | ACTIVE        |  =  | move    |
  | failed       | STANDBY       |  ===>  | stopped      | ACTIVE        |  =  | stop    |
  | stopped      | ACTIVE        |  ===>  | STANDBY      | ACTIVE        |  =  | return  |
  | ACTIVE       | stopped       |  ===>  | ACTIVE       | STANDBY       |  =  | return  |
  | ACTIVE       | STANDBY       |  ===>  | ACTIVE       | stopped       |  =  | disable |
  +--------------+---------------+--------+--------------+---------------+-----+---------+
"""
SITE_HELP_SECTION = """define the cluster name.
This site:
  will be active in case of move 
  will be standby in case of stop
  will be standby in case of return
  will be disable to maintenance in case of disable
"""

done_services = []
ignored_services = []
failed_services = []

args = None
module_flow = [{'stateful': None}]  # custom DR sequence per module
default_module = 'stateful'
state_restrictions = {}

thread_pool=[]

SERVICE_DEFAULT_TIMEOUT = None
thread_result_queue = Queue(maxsize=-1)

readonly_cmd = ("status", "list")
dr_procedures =("move", "stop") + readonly_cmd  # DR procedures: switchover, failover
site_cmds =("active", "standby", "return", "disable") + readonly_cmd  # per site commands

run_services = []
skip_services = []


class SMConf(dict): # global config.yaml and some RO config parameters and args, cmd manipulation

    def get_active_site(self, cmd, site):
        if cmd in ["active", "move"]:
            return site
        elif cmd in ["stop", "standby", 'disable']:
            return self.get_opposite_site(site)
        else:
            return None

    def get_opposite_site(self,site):
        if site not in self.keys():
            return None
        opposite_site=None

        for s in sm_conf.keys():
            if s != site:
                opposite_site=s
        return opposite_site

    def convert_sitecmd_to_dr_mode(self,site_cmd):
        """ Converts <site_cmd>  into DR mode ["active","standby","disable"]
        """
        if site_cmd == "return":
            return "standby"
        else:  # "active","standby" are modes.
            return site_cmd


sm_conf = SMConf()


def init_and_check_config(args) -> bool:
    """ Main entry point. Provides validations, config parsing and initialization
    @returns: True of False  """
    #@todo python version check; version print

    # Set verbosity for logging
    logger = logging.getLogger()
    logger.setLevel(logging.DEBUG)

    ch = logging.StreamHandler()
    if args.verbose:
        ch.setLevel(logging.DEBUG)
        ch.setFormatter(logging.Formatter("%(asctime)s [%(levelname)s] %(filename)s.%(funcName)s(%(lineno)d): %(message)s"))
    else:
        ch.setLevel(logging.INFO)
        ch.setFormatter(logging.Formatter("%(asctime)s [%(levelname)s] %(filename)s: %(message)s"))

    logging.basicConfig(handlers=[ch])
    if args.output:
        log_output = None
        if pathlib.Path(args.output).is_file():
            log_output = pathlib.Path(args.output).expanduser() if os.access(args.output, os.W_OK) else None
        elif os.access(pathlib.Path(args.output).expanduser().parent.resolve(), os.W_OK) and \
                not pathlib.Path(args.output).expanduser().is_dir(): # do not take into account provided dirs
            log_output = pathlib.Path(args.output).expanduser()

        if not log_output:
            logging.critical(f"Cannot write to {args.output} file. Printing stdout ...")
        else:
            fh = logging.FileHandler(log_output)
            fh.setLevel(logging.DEBUG)
            fh.setFormatter(logging.Formatter("%(asctime)s [%(levelname)s] %(filename)s.%(funcName)s(%(lineno)d): %(message)s"))
            fh.emit(logging.LogRecord("",logging.INFO,sys.argv[0], 0, args.command,None,None)) # add delimeter in logfile

            logger.addHandler(fh)

    logging.debug(f"Script arguments: {args}")

    # Define, check and load configuration file
    conf_file = os.path.join(os.path.dirname(os.path.abspath(__file__)), "config.yaml") if args.config == "" else args.config
    if not os.path.isfile(conf_file):
        logging.fatal("You should define configuration file for site-manager or copy it to config.yaml in site-manager main directory")
        exit(1)

    try:
        conf_parsed = yaml.load(open(conf_file), Loader=yaml.FullLoader)
    except:
        logging.fatal("Can not parse configuration file!")
        return False

    logging.debug(f"Parsed config: {conf_parsed}")

    global FRONT_HTTP_AUTH
    FRONT_HTTP_AUTH = conf_parsed.get("sm-client", {}).get("http_auth", False)

    global SERVICE_DEFAULT_TIMEOUT
    SERVICE_DEFAULT_TIMEOUT = conf_parsed.get("sm-client", {}).get("service_default_timeout", 200)

    global ignored_services
    ignored_services.clear()

    global run_services
    # Check services for running
    if args.run_services != '':
        run_services = args.run_services.replace(',', ' ').replace('  ', ' ').split(' ')
    else:
        run_services.clear()

    global skip_services
    if args.skip_services != '':
        skip_services = args.skip_services.replace(',', ' ').replace('  ', ' ').split(' ')
    else:
        skip_services.clear()

    global failed_services
    failed_services.clear()

    global state_restrictions
    state_restrictions = conf_parsed.get("restrictions", {}) if not args.ignore_restrictions else {}

    global module_flow
    module_flow = conf_parsed.get("flow", [{'stateful': None}])
    site_names = [i["name"] for i in conf_parsed["sites"]]
    global sm_conf
    sm_conf = SMConf()
    for site in site_names:
        try:
            site_url = [ i["site-manager"] for i in conf_parsed["sites"] if i ["name"] == site ][0]
        except KeyError:
            logging.error("Check configuration file. Some of sites does not have 'site-manager' parameter")
            return False

        site_token = [ i.get("token", "") for i in conf_parsed["sites"] if i ["name"] == site ][0]
        site_cacert = [ i.get("cacert", True) for i in conf_parsed["sites"] if i ["name"] == site ][0]

        if site_cacert != True and not os.path.isfile(site_cacert):
            logging.fatal(f"You should define correct path to CA certificate for site {site}")
            return False
        sm_conf[site] = {}
        sm_conf[site]["url"] = site_url
        sm_conf[site]["token"] = site_token
        sm_conf[site]["cacert"] = False if args.insecure else site_cacert

    # Check state restrictions
    for restrictions_list in state_restrictions.values():
        if any(state_str.count('-') + 1 != len(sm_conf) for state_str in restrictions_list):
            logging.error(f"Check configuration file. Some state restrictions don't suitable for the current number of sites")
            return False

    return True


class ServiceDRStatus:
    def __getitem__(self, key):
        return self.__getattribute__(key)

    def __init__(self, data: dict = None ): # {'services':{service_name:{}}}
         if data and data.get("services") and isinstance(data['services'],dict):
             self.service = list(data['services'].keys())[0]
         elif data and data.get("wrong-service") and isinstance(data['wrong-service'],str):
             self.service = data['wrong-service']
         else:
             raise ValueError("Missing service name")
         serv = data['services'][self.service] if data.get('services') else data
         self.mode = serv['mode'] if serv.get("mode") in ["active", "standby", "disable"] else "--"
         self.nowait = serv["nowait"] if serv.get("nowait") else False
         self.healthz = serv["healthz"] if serv.get("healthz") in ["up", "down", "degraded"] else "--"
         self.status = serv["status"] if serv.get("status") in ["running","done","failed"] else "--"
         self.message = serv["message"] if serv.get("message") else ""
         # https://github.com/Netcracker/DRNavigator/blob/b4161fb15271485974abf5862e7272abc386fbc8/modules/stateful.py#L16

    def is_ok(self):
        if self.healthz in ['down','degraded','--'] or self.status in ['failed']:
            return False
        return True

    def sortout_service_results(self):
        """ Put service name in appropriate list(failed or done) """
        if self.is_ok():  # return Ok - done_service
            if self.service not in failed_services:
                done_services.append(self.service) if self.service not in done_services else None
        else:
            failed_services.append(self.service) if self.service not in failed_services else None
            done_services.remove(self.service) if self.service in done_services else None


class SMClusterState:
    def __init__(self,site=None):
        def init_default(sitename):
            if len(self.sm.keys()) == 2:
                raise ValueError("Only two sites in clusters are supported")
            self.sm[sitename]={}
            self.sm[sitename]["services"]={}
            self.sm[sitename]["return_code"]=None
            self.sm[sitename]["status"]=False #ServiceDRStatus
            self.sm[sitename]["service_dep_ordered"]=None
            self.sm[sitename]["ts"]=None
            self.sm[sitename]["dep_issue"]=None

        global sm_conf
        if not site or (site and isinstance(site, str)): #@todo rework
            if site and site not in sm_conf.keys():
                raise ValueError("Unknown site name")
            self.sm = {}
            for sitename in [s for s in sm_conf.keys() if site == s] if site else sm_conf.keys():
                init_default(sitename)
        elif isinstance(site,dict): # for dev/testing purposes
            self.sm = {}
            for key in site.keys():
                init_default(key)
                for k,v in site[key].items():
                    self.sm[key][k] = v

    def __getitem__(self, key):
        return self.sm[key]

    def __setitem__(self, key, item):
        self.sm[key] = item

    def __str__(self):
        return str(self.sm)

    def keys(self):
        return self.sm.keys()

    def get_dr_operation_sequence(self, serv, procedure, site) -> [[], []]:  # move active, stop standby
        """ Get DR operation(cmd) site sequence in the correct order for specific service for provided DR procedure
        @returns: [['site1','standby'],['site2','active']] - default in case sequence is empty
        @todo to rework when sm_dict[site|opposite]['services'][serv] serv is not present on one site
        """
        opposite_site = sm_conf.get_opposite_site(site)
        site_sequence=[]
        if procedure == 'move':  # switchover
            mode, = self.sm[site]['services'][serv]['sequence'][0:1] or ['standby']
            if mode == 'standby':
                site_sequence=[[opposite_site, 'standby'], [site, 'active']]
            elif mode == 'active':
                site_sequence=[[site, 'active'], [opposite_site, 'standby']]
        elif procedure == 'stop':  # failover
            mode, = self.sm[opposite_site]['services'][serv]['sequence'][0:1] or ['standby']
            if mode == 'standby':
                site_sequence=[[site, 'standby'], [opposite_site, 'active']]
            elif mode == 'active':
                site_sequence=[[opposite_site, 'active'], [site, 'standby']]
        else:
            raise Exception("Wrong command")

        return site_sequence

    def get_available_sites(self) -> []:
        """ Return list of available sites """
        return [site for site in self.sm.keys() if self.sm[site]['status']]

    def get_services_list_for_ok_site(self) -> []:
        final_set=set()
        for site in self.sm.values():
            final_set=final_set.union(set(list(site['services'].keys())))
        return list(final_set)

    def get_module_services(self, site, module) -> []:
        module_list=[]
        for serv in self.sm[site]['services'].keys():
            if self.sm[site]['services'][serv].get('module') and module == self.sm[site]['services'][serv]['module']:
                module_list.append(serv)
        return module_list

    def make_ignored_services(self, service_dep_ordered: list) -> []:
        """ Make list of services which are not intended to run, ignored."""
        ignored_list=[]
        for site in self.sm.keys():
            for serv in self.sm[site]['services']:
                if serv not in service_dep_ordered and serv not in ignored_services:
                    ignored_list.append(serv)
        return list(set(ignored_list))


def sm_get_cluster_state(site=None) -> SMClusterState:
    """ Get cluster status or per specific site and init sm_dict object
    """
    sm_dict = SMClusterState(site)
    for site_name in sm_dict.keys():
        response, ret, code = sm_process_service(site_name, "site-manager", "status")
        sm_dict[site_name]["return_code"] = code # HTTP or SSL
        sm_dict[site_name]["status"] = ret
        sm_dict[site_name].update(response)
        #### TODO to remove hack once replicator module is updated accordingly
        if sm_dict[site_name]["status"] and sm_dict[site_name]['services'].get('cluster-replicator'):
            sm_dict[site_name]['services']['cluster-replicator']['module'] = 'replicator'
    return sm_dict


def sm_process_service_with_polling(service, site, cmd, sm_dict) -> None:
    global thread_result_queue

    service_response = ServiceDRStatus({'services':{service:{}}})

    logging.info(f"Processing {service} in thread start...")
    if cmd in site_cmds:
        mode=sm_conf.convert_sitecmd_to_dr_mode(cmd)
        sm_process_service(site, service, mode)
        service_response = sm_poll_service_required_status(site, service, mode, sm_dict)
        thread_result_queue.put(service_response)
    elif cmd in dr_procedures:
        # todo to handle False(no service on this site)
        for site_to_process, mode in sm_dict.get_dr_operation_sequence(service, cmd, site):
            if cmd == "stop" and mode == "standby":
                force = True
                logging.info(f"Force key enabled for procedure 'stop' for service {service} on passivated site")
            else:
                force = args.force

            if sm_dict[site_to_process]['status']: # to process only available sites
                sm_process_service(site_to_process, service, mode, False if 'move' in cmd else True)
                service_response = sm_poll_service_required_status(site_to_process, service, mode, sm_dict, force)
                if cmd in 'move' and not service_response.is_ok():
                    logging.info(f"Service {service} failed on {site_to_process}, skipping it on another site...")
                    break

        thread_result_queue.put(service_response)

    logging.info(f"Processing {service} in thread finished")


class NotValid(Exception):
    """ Raised when it is not possible to process specified command on current cluster state"""
    pass


class TopologicalSorter2(TopologicalSorter):
    """ added method to get successors of specific node """
    def successors(self, node):
        for i in self._node2info.values():
            if i.node == node:
                return i.successors
        return None


def print_service_order(ts: TopologicalSorter2, sm_dict: SMClusterState):
    """ Show service list ordered by dependency in debug mode"""
    stage=0
    logging.debug(f"Service order by dependency:")
    if len(module_flow) > 1:  # print custom module service name
        services_name=''
        for _ in sm_dict.get_available_sites():
            if sm_dict.get_module_services(_, list(module_flow[0].keys())[0]):
                services_name=sm_dict.get_module_services(_, list(module_flow[0].keys())[0])[0]
        logging.debug("--------------------")
        logging.debug(f"{services_name}")
    while ts and ts.is_active():  # process all services one by one  in  sorted by dependency
        stage += 1
        logging.debug(f"------ Stage {stage} -------")
        for serv in ts.get_ready():
            logging.debug(f"{serv}")
            ts.done(serv)
    logging.debug("Done. ----------------")


def process_ts_services(ts:TopologicalSorter2, process_func, *run_args:()) -> None:
    """ Runs services in ts object one-by-one on both sites using process_func method.
    process_func have to put  ServiceDRStatus result in thread_result_queue  queue
    @param ts: TopologicalSorter2
    @param process_func: method with 1 mandatory param - service name from ts
    @param run_args: list of additional params  passed to process_func
    """
    failed_successors=[]
    serv_thread_pool=[]
    global thread_result_queue

    while ts and ts.is_active():  # process all services one by one  in  sorted by dependency
        for serv in ts.get_ready():
            if serv in failed_successors:
                logging.info(f"Service {serv} marked as failed due to dependencies")
                thread_result_queue.put(ServiceDRStatus({'services':{serv:{}}}))
                break
            thread=threading.Thread(target=process_func,
                                    args=(serv,) + run_args)
            thread.name=f"Thread: {serv}"
            serv_thread_pool.append(thread)
            thread.start()
        service_response = thread_result_queue.get()

        if not service_response.is_ok() :  # mark failed and skip successors of serv_done
            for s in ts.successors(service_response.service):
                logging.debug(f"Found successor {s} for failed {service_response.service} ")
                failed_successors.append(s)
        ts.done(service_response.service)
        service_response.sortout_service_results()
    for thread in serv_thread_pool:
        thread.join()


def run(services:[] = None, cmd="", site=""):
    """ Business Logic - implements main flow """

    # init SMClusterState object ann get status for all sites in case DR procedure or specific site in case cmd
    sm_dict = sm_get_cluster_state(None)

    # assemble ordered service list to proceed, keeping in services specified in cli
    for site_i in sm_dict.get_available_sites():
        service_dep_ordered, return_code, ts = make_ordered_services_to_process(sm_dict, site_i, services)
        sm_dict[site_i]['service_dep_ordered'] = service_dep_ordered
        sm_dict[site_i]['ts'] = ts
        sm_dict[site_i]['deps_issue'] = not return_code
        logging.debug(f"Site:{site_i} list:{sm_dict[site_i]['service_dep_ordered']} deps_issue:{sm_dict[site_i]['deps_issue']}")

    # validation to satisfy cmd and current site status
    service_dep_ordered = None; ts = None
    try:
        service_dep_ordered, ts = validate_operation(sm_dict, cmd, site, services)
        for _mod in module_flow: # add custom module service
            module = list(_mod.keys())[0]
            if module not in default_module and sm_dict.get_module_services(sm_dict.get_available_sites()[0], module):
                services_name = sm_dict.get_module_services(sm_dict.get_available_sites()[0], module)[0]
                if (services_name in services if services else True) and services_name not in service_dep_ordered and \
                        services_name not in ignored_services:
                    service_dep_ordered.insert(0, services_name)
        logging.debug(f"Service order {service_dep_ordered}")
    except NotValid:
        exit(1)

    ignored_services.extend(sm_dict.make_ignored_services(service_dep_ordered))

    # main flow by command
    if cmd in "status":
        for serv in service_dep_ordered:
            def run_in_thread(site, serv, sm_dict):  # to run each status service in parallel
                response, _, return_code=sm_process_service(site, serv, "status")
                if not sm_dict[site]['services'].get(serv):
                    sm_dict[site]['services'][serv]={}
                sm_dict[site]['services'][serv]['status']=ServiceDRStatus(response) if return_code else False

            for site_i in sm_dict.get_available_sites():
                thread=threading.Thread(target=run_in_thread, args=(site_i, serv, sm_dict))
                thread.name = f"Thread: {serv}"
                thread.start()
                thread_pool.append(thread)
        for thread in thread_pool:
            thread.join()
        print_service_order(ts,sm_dict)
        print_main_table(sm_dict, service_dep_ordered, [site] if site else [_ for _ in sm_conf.keys()])
    elif cmd in "list":
        print(f"---------------------------------------------------------------------\n" +
              f"Sites managed by site-manager:               {[site for site in sm_dict.keys()]}\n\n" +
              f"Kubernetes services managed by site-manager: {sm_dict.get_services_list_for_ok_site()}\n" +
              f"Kubernetes services that will be processed:  {service_dep_ordered}\n" +
              f"---------------------------------------------------------------------")
    elif cmd in site_cmds + dr_procedures:  # per site command or DR procedure
        print_service_operation_summary("top", sm_dict, service_dep_ordered, cmd, site)

        def run_module(module, state):
            """@todo need more flexible module support """
            logging.info(f"Processing {module} module to mode:{state}")
            if module not in default_module:
                if cmd in dr_procedures:
                    if state in 'active':
                        site_to_run = sm_conf.get_opposite_site(site)
                    else:
                        site_to_run = site
                    site_to_run = sm_conf.get_opposite_site(site_to_run) if cmd in 'move' else site_to_run
                else:
                    site_to_run = site
                service_to_run = sm_dict.get_module_services(sm_dict.get_available_sites()[0], module)[0]
                if service_to_run in service_dep_ordered and sm_dict[site_to_run]['status']:
                    logging.debug(f"on site {site_to_run}. Services {service_to_run}  ")
                    sm_process_service(site_to_run, service_to_run, state, False if 'move' in cmd else True)
                    response=sm_poll_service_required_status(site_to_run, service_to_run,
                                                             sm_conf.convert_sitecmd_to_dr_mode(state), sm_dict)
                    response.sortout_service_results()
            else:  # stateful module
                process_ts_services(ts, sm_process_service_with_polling, site, cmd, sm_dict)

        dr_status = True
        for elem in module_flow:
            for module, states in elem.items():
                if not dr_status:
                    for i in sm_dict.get_module_services(sm_dict.get_available_sites()[0], module):
                        if i in service_dep_ordered:
                            ServiceDRStatus({'services':{i:{'status':'failed'}}}).sortout_service_results()
                    break
                if cmd in ['standby', 'disable', 'return'] and (states and states == ['active']):
                    break
                if cmd in 'active' and (states and set(states) == {'standby', 'disable'}):
                    continue

                def get_state(cmd, states) -> str:
                    if not states:
                        return ''

                    if cmd in ['move', 'stop']:
                        return states[0]
                    elif cmd in ['disable']:
                        return 'disable'
                    else:
                        return states[0]
                run_module(module, get_state(cmd,states))
                if failed_services:
                    logging.debug(f"Module {module} failed. Failed services {failed_services}")
                    logging.error(f"Module {module} failed, skipping rest of services, exiting")
                    dr_status = False
                    break
        print_service_operation_summary("tail",sm_dict, service_dep_ordered, cmd, site )
    else:
        logging.error(f"Unknown combination of {cmd} {site} options")
        exit(1)

    if len(failed_services) != 0:
        logging.fatal(f"Some services finished {cmd} with failed status")
        exit(1)

    return True


def print_service_operation_summary(part, sm_dict: SMClusterState, services_to_run: [], cmd="", site=""):
    if part in "top":
        logging.info("---------------------------------------------------------------------")
        logging.info(f"Procedure:     {cmd}")
        logging.info(f"Active sites:  {sm_conf.get_active_site(cmd, site)}")
        logging.info(f"Standby sites: {sm_conf.get_opposite_site(sm_conf.get_active_site(cmd, site))}")
        logging.info(f"Kubernetes services managed by site-manager: {sm_dict.get_services_list_for_ok_site()}")
        logging.info(f"Kubernetes services that will be processed:  {services_to_run}")
        logging.info("---------------------------------------------------------------------")
    elif part in "tail":
        logging.info("---------------------------------------------------------------------")
        logging.info("Summary:")
        logging.info(f"services that successfully done: {list(dict.fromkeys(done_services))}")
        logging.info(f"services that failed:            {failed_services}")
        logging.info(f"services that ignored:           {ignored_services}")
        logging.info("---------------------------------------------------------------------")


def make_ordered_services_to_process(sm_dict: SMClusterState, site, services_to_process: list = None ) -> Tuple[list, bool, Optional[TopologicalSorter2]]:
    """ Make ordered and validated services list from all sites in sm_dict
    @returns: ordered list or empty if not possible to assemble(integrity issue), True or False  in case minor issue
        TopologicalSorter object in case success
    @todo[3]: cross site validation
    """
    def build_after_before_graph(dep_list: dict) -> TopologicalSorter2:
        """Assemble directed graph using AFTER and BEFORE dependency
        @param dep_list:[]: services list with deps in special format, see @note
        @returns: TopologicalSorter graph
        @todo: [3] multiple dependency service support
        @note:  format of input list  [{'serv2':{'after':['serv1'],'before':['serv3']}},...]
        """
        ts = TopologicalSorter2()
        for item in dep_list.keys():
            ts.add(item)
            if dep_list[item].get('after') and dep_list[item]['after'][0] in [ii for ii in dep_list.keys()]:
                ts.add(item, dep_list[item]['after'][0]) #if dep[AFTER,BEFORE] is present and exist in the dep_list - add it
            if dep_list[item].get('before') and dep_list[item]['before'][0] in [ii for ii in dep_list.keys()]:
                ts.add(dep_list[item]['before'][0], item)
        return ts

    def after_before_check(ll: dict) -> {}:
        """ Check AFTER and BEFORE dependency integrity
        @returns: dict of services if any with non exist deps , see format in @note
        @note: the return dict format {service:{'before':wrong_dep}}}
        """
        wrong_dep_list={}
        for i in ll.keys():
            if ll[i]['after'] and  ll[i]['after'][0] not in [ii for ii in ll.keys()]: #if wrong dep - collect them
                if not wrong_dep_list.get(i):
                    wrong_dep_list[i]={}
                wrong_dep_list[i]['after'] = ll[i]['after']

            if ll[i]['before'] and ll[i]['before'][0] not in [ii for ii in ll.keys()]: #if wrong dep - collect them
                if not wrong_dep_list.get(i):
                    wrong_dep_list[i]={}
                wrong_dep_list[i]['before'] = ll[i]['before']

        return wrong_dep_list

    ret = True
    integrity_error = False
    temp_dict = copy.deepcopy(sm_dict)

    # leave only service listed in service_to_process and not skipped/ignored
    for serv in temp_dict[site]['services'].copy().keys():
        if temp_dict[site]['services'][serv].get('module',"") not in default_module:
            temp_dict[site]['services'].pop(serv, None)
        if services_to_process and serv not in services_to_process:
            temp_dict[site]['services'].pop(serv,None)
        if ignored_services and serv in ignored_services: # remove skipped/ignored
            temp_dict[site]['services'].pop(serv, None)


    # collect sorted ordered service list
    service_lists = []
    try:
        service_lists = [i for i in build_after_before_graph(temp_dict[site]['services']).static_order()]
        for service, depends in after_before_check(temp_dict[site]['services']).items():  # check deps
            for depend in depends:
                logging.warning(f"Site: {site}. Service: {service} has nonexistent "
                                f"{depend} dependency: {depends[depend]}")
                ret = False
    except CycleError as e:
        logging.error(f"Site {site} has integrity issues: %s",e)
        integrity_error = True

    if integrity_error:
        return [], False, type(None) # return error, integrity issue

    # check services equality on all sites
    ts = build_after_before_graph(temp_dict[site]['services'])
    ts.prepare()
    return service_lists, ret, ts


def validate_operation(sm_dict: SMClusterState, cmd, site=None, services_to_run=None) -> Tuple[list, TopologicalSorter2]:
    """ Validate command compliance to current site state
    @param sm_dict: populated sm_dict
    @returns: Allowed or not to proceed operation <cmd> on <site>
    @todo warn/fail in case deps are different
    """
    def check_site_ssl_available(checked_site: str):
        if not sm_dict[checked_site]['status']:
            logging.error(f"Site: {checked_site} is not available")
            if sm_dict[checked_site]['return_code'] == ssl.SSLErrorNumber.SSL_ERROR_SSL.__int__():
                logging.error(f"SSL certificate verify failed for site:{checked_site}. Please use key -k or --insecure")
            return False
        return True

    def check_services_on_site(services, site):
        ret = True
        for s in services:
            if s not in sm_dict[site]["services"].keys():
                logging.warning(f"Service '{s}' does not exist on '{site}' site")
                ret = False
        return ret

    def check_dep_issue(site):
        if sm_dict[site]['deps_issue']:
            logging.warning(f"Dependency issues on site: {site}")
            return False
        return True

    def check_state_restrictions(services):
        state_is_valid = True
        # Get services, that should be predicted
        services_to_predict = services if "*" in state_restrictions else \
           [service for service in services if service in state_restrictions.keys()]
        logging.debug(f"Services to predict {services_to_predict}")
        # Predict state for services and compare with restrictions
        for service in services_to_predict:
            # Convert restricted states
            restricted_states_list = []
            for restricted_state_str in state_restrictions.get(service, []) + state_restrictions.get("*", []):
                restricted_states_list.append(dict(zip(sm_conf.keys(), restricted_state_str.split("-"))))
            logging.debug(f"Restricted states for service {service}: {restricted_states_list}")

            # Get state on opposite site
            opposite_site = sm_conf.get_opposite_site(site)
            response, ret, _ = sm_process_service(opposite_site, service, "status")
            if not ret:
                logging.error(f"Can't get service {service} on site {opposite_site}")
                state_is_valid = False
                continue
            serviceDRstatus = ServiceDRStatus(response)
            if serviceDRstatus.mode == '---':
                logging.error(f"Can't recognize current mode for service {service} on site {opposite_site}")
                state_is_valid = False
                continue

            # Predicted state
            state = {site: sm_conf.convert_sitecmd_to_dr_mode(cmd), opposite_site: serviceDRstatus.mode}
            logging.debug(f"Predicted state for service {service}: {state}")
            if state in restricted_states_list:
                logging.error(f"Final state {state} for service {service} is restricted")
                state_is_valid = False
        if not state_is_valid:
            logging.error(f"State restrictions validation fail. To skip it use --ignore-restrictions option")
        return state_is_valid


    global sm_conf
    service_dep_ordered = None ; ts = None
    ret = True

    if cmd in "stop":
        # check site availability
        if not check_site_ssl_available(sm_conf.get_opposite_site(site)) or \
                not check_dep_issue(sm_conf.get_opposite_site(site)):
            raise NotValid
        service_dep_ordered = services_to_run if services_to_run else \
            sm_dict[sm_conf.get_opposite_site(site)]['service_dep_ordered']
        check_services_on_site(service_dep_ordered, sm_conf.get_opposite_site(site))
        ts=sm_dict[sm_conf.get_opposite_site(site)]['ts']

    elif cmd in "move":
        service_dep_ordered = services_to_run if services_to_run else \
            sm_dict[site]['service_dep_ordered']
        if not all(check_site_ssl_available(site_i) for site_i in sm_conf.keys()) or \
                not all(check_services_on_site(service_dep_ordered, site_i) for site_i in sm_conf.keys()) or \
                not all(check_dep_issue(site_i) for site_i in sm_conf.keys()):
            raise NotValid
        if set(sm_dict[site]['service_dep_ordered']) != \
                set(sm_dict[sm_conf.get_opposite_site(site)]['service_dep_ordered']):
            logging.critical(f"Not able to perform 'move' operation because of different service lists on sites ")
            raise NotValid
        ts=sm_dict[site]['ts']

    elif cmd in readonly_cmd:
        ret = any([check_site_ssl_available(site)] if site else
                  [check_site_ssl_available(s) for s in sm_conf.keys()])
        if not ret:
            raise NotValid

        if len(sm_dict.get_available_sites()) > 1 and \
                len(sm_dict[sm_dict.get_available_sites()[0]]['service_dep_ordered']) >= \
                len(sm_dict[sm_dict.get_available_sites()[1]]['service_dep_ordered']):
            service_dep_ordered=sm_dict[sm_dict.get_available_sites()[0]]['service_dep_ordered']
            ts=sm_dict[sm_dict.get_available_sites()[0]]['ts']
        elif len(sm_dict.get_available_sites()) > 1:
            service_dep_ordered=sm_dict[sm_dict.get_available_sites()[1]]['service_dep_ordered']
            ts=sm_dict[sm_dict.get_available_sites()[1]]['ts']
        else:
            service_dep_ordered=sm_dict[sm_dict.get_available_sites()[0]]['service_dep_ordered']
            ts=sm_dict[sm_dict.get_available_sites()[0]]['ts']
        if services_to_run:
            service_dep_ordered = services_to_run
        all(check_services_on_site(service_dep_ordered, site_i) for site_i in sm_dict.get_available_sites())
        all(check_dep_issue(site_i) for site_i in sm_dict.get_available_sites())

    elif cmd in site_cmds:

        service_dep_ordered = services_to_run if services_to_run else \
            sm_dict[site]['service_dep_ordered']
        if not check_site_ssl_available(site) or \
                not check_services_on_site(service_dep_ordered, site) or \
                not check_dep_issue(site) or \
                not check_state_restrictions(services_to_run if services_to_run else sm_dict[site].get('services', {}).keys()):
            raise NotValid
        ts=sm_dict[site]['ts']

    else:
        ret = False

    if not ret:
        raise NotValid

    return service_dep_ordered,ts


def sm_process_service(site, service, site_cmd: str, no_wait=True, force=False) -> Tuple[Dict, bool, int]:
    """ Processes the service with specific site cmd """
    global sm_conf

    if site_cmd in ["status","list"]:  # RO operations
        body = {} if service == "site-manager" else {"procedure": "status", "run-service": service}
    else:
        body = {"procedure": sm_conf.convert_sitecmd_to_dr_mode(site_cmd), "run-service": service, "no-wait": no_wait, "force": force}

    ret, response, return_code = io_make_http_json_request(sm_conf[site]["url"],
                                                           sm_conf[site]["token"],
                                                           sm_conf[site]["cacert"],
                                                           body,
                                                           use_auth=FRONT_HTTP_AUTH)
    return response,True if return_code == HTTPStatus.OK else False, return_code


def sm_poll_service_required_status(site, service, mode, sm_dict, force: bool = False) -> ServiceDRStatus:
    """ Polls service status command till desired mode is reached
        @param force: True/False --force mode to ignore healthz
    """
    def service_status_polling(site, service, expected_state:{}, error_states: [], delay=5) -> Dict:
        """  Polls "site-manager status" <service> command till <expected_state> dict or
        error_state dict returns during <timeout> period with <delay>
        @param expected_state:  expected dict state from site-manager service status command. {"status": ["up"]}
        @param error_states:  error states in case return immediately. [{"status": ["failed"]}]
        """
        timeout = sm_dict[site]["services"][service]["timeout"] if sm_dict[site]["services"].get(service, {})\
                                                                       .get("timeout", None) is not None  else \
                                                                        SERVICE_DEFAULT_TIMEOUT

        init_time = int(time.time())
        count = 0
        data = {'services':{service:{}}}
        while int(time.time()) <= init_time + int(timeout):
            count += 1

            logging.info(f"Service: {service}. Site: {site}. Polling procedure {expected_state} Iteration {count}")
            logging.info(f"Service: {service}. Site: {site}. {int(timeout) - (int(time.time()) - init_time)} seconds left until timeout")

            data, ret, _ = sm_process_service(site, service, "status")
            data = {'services':{service:{}}} if not data else data

            logging.info(f"Service: {service}. Site: {site}. Received data: {data}. Return code: {ret}")

            def check_state():
                for error_state in error_states:
                    if all(data["services"][service][key] in val for key, val in expected_state.items()):
                        logging.info(f"Service: {service}. Site: {site}. Expected state {expected_state} occurred.")
                        return True
                    elif all(data["services"][service][key] in val for key, val in error_state.items()):
                        logging.info(f"Service: {service}. Site: {site}. Error state {error_state} occurred.")
                        return True
                return False

            if ret and check_state():
                return data
            else:
                time.sleep(delay)
                continue

        logging.info(f"Service: {service}. Site: {site}. Timeout expired.")
        return data

    if mode == "standby":
        data = service_status_polling(site, service,
                                      {"status": ["done"], "mode": [mode], "healthz":
                                               sm_dict[site]["services"][service]["allowedStandbyStateList"]},
                                      [{'status': ['done'], 'healthz': ['down', 'degraded']},
                                       {'status': ['failed']}])
    else:  # active and rest commands
        data = service_status_polling(site, service,
                                      {"status": ["done"], "mode": [mode], "healthz": ["up"]},
                                      [{'status':['done'], 'healthz':['down', 'degraded']},
                                       {'status':['failed']}])

    if force:
        logging.warning(f"Service: {service}. Force mode enabled. Service healthz ignored")
        stat = ServiceDRStatus(data)
        stat.healthz = "up"
        return stat

    return ServiceDRStatus(data)


def print_main_table(sm_dict: SMClusterState, services_to_run, sites_name: []):
    """ Method intended to display main section of status table
    @param dict sm_dict: the results of the procedure received from the site-manager
    @param list services_to_run: the list of services that have been processed
    @param list sites_name: list of cluster names
    """
    def make_table(header, sites_name):
        """
        Method for creating the main parts of the table
        """

        pt=PrettyTable()
        pt_field_names=["Service"]

        for sites_item in sites_name:
            pt_field_names.append(f"{sites_item}")

        pt.field_names=pt_field_names
        pt.align["Service"]="l"

        # Additional header
        comment_pt_row = [""]
        separator_pt_row = ["--------------------------"]

        for sites_item in sites_name:
            comment_pt_row.append(header)
            separator_pt_row.append("------------------------------------")

        pt.add_row(comment_pt_row)
        pt.add_row(separator_pt_row)
        pt.max_width = 50
        return pt
    pt = make_table("mode | DR status | healthz | message", sites_name)
    for service_item in services_to_run:
        service_pt_row = list()
        service_pt_row.append(service_item)
        for sites_item in sites_name:
            if sm_dict[sites_item]['status'] and sm_dict[sites_item]['services'].get(service_item) and \
                    sm_dict[sites_item]['services'][service_item].get('status'):
                if len(sm_dict[sites_item]['services'][service_item]['status']['message']) <= pt.max_width['Service']:
                    service_pt_row.append(
                        f"{sm_dict[sites_item]['services'][service_item]['status']['mode']} / "
                        f"{sm_dict[sites_item]['services'][service_item]['status']['status']} / "
                        f"{sm_dict[sites_item]['services'][service_item]['status']['healthz']} / "
                        f"{sm_dict[sites_item]['services'][service_item]['status']['message']}")
                else:
                    logging.warning(sites_item + ': ' + service_item + ' - ' +
                                     sm_dict[sites_item]['services'][service_item]['status']['message'])
                    service_pt_row.append(
                        f"{sm_dict[sites_item]['services'][service_item]['status']['mode']} / "
                        f"{sm_dict[sites_item]['services'][service_item]['status']['status']} / "
                        f"{sm_dict[sites_item]['services'][service_item]['status']['healthz']} / "
                        f"{sm_dict[sites_item]['services'][service_item]['status']['message'][:10] + '...'}")
            else:
                service_pt_row.append("-- / -- / -- /")
        pt.add_row(service_pt_row)

    print(pt)


def parse_command_line(command_args) -> argparse.Namespace:
    """ Main argument parser
    @return:
    """
    parser = argparse.ArgumentParser(description=MAIN_HELP_SECTION,
                                     argument_default=argparse.SUPPRESS,
                                     formatter_class=argparse.RawTextHelpFormatter)

    parser.add_argument('-v', '--verbose', default=False, action='store_true', help='enable the verbosity mode')
    parser.add_argument('-c', '--config', default="", help='define the path to configuration file')
    parser.add_argument('-f', '--force', default=False, action='store_true', help='force apply DR action and ignore healthz')
    parser.add_argument('-k', '--insecure', default=False, action='store_true', help='enable self-signed certificates')
    parser.add_argument('-o', '--output', default="", help='define the filename for logging output')
    parser.add_argument('-r', '--ignore-restrictions', default=False, action='store_true', help='skip state restrictions validation')

    parser.add_argument('--run-services', default='', help='define the list of services to apply DR action, by default all services participate')
    parser.add_argument('--skip-services',  default='', help='define the list of services what will not participate in DR action')

    subparsers = parser.add_subparsers()
    subparsers.required=True

    parser_1 = subparsers.add_parser('move', help='move Active functionality to Standby site')  # DR switchover
    parser_1.add_argument('site', help=SITE_HELP_SECTION)
    parser_1.set_defaults(command='move')

    parser_2 = subparsers.add_parser('stop', help='excludes site from Active-Standby scheme')  # DR failover
    parser_2.add_argument('site', help=SITE_HELP_SECTION)
    parser_2.set_defaults(command='stop')

    parser_3 = subparsers.add_parser('return', help='return stopped Kubernetes cluster to Standby role')
    parser_3.add_argument('site', help=SITE_HELP_SECTION)
    parser_3.set_defaults(command='return')

    parser_4 = subparsers.add_parser('disable', help='stop Standby kubernetes cluster for maintenance')
    parser_4.add_argument('site', help=SITE_HELP_SECTION)
    parser_4.set_defaults(command='disable')

    parser_5 = subparsers.add_parser('active', help='set kubernetes cluster services to active mode')
    parser_5.add_argument('site', help=SITE_HELP_SECTION)
    parser_5.set_defaults(command='active')

    parser_6 = subparsers.add_parser('standby', help='set kubernetes cluster services to standby mode')
    parser_6.add_argument('site', help=SITE_HELP_SECTION)
    parser_6.set_defaults(command='standby')

    parser_7 = subparsers.add_parser('list', help='list all services from Active-Standby scheme managed by site-manager with dependencies')
    parser_7.add_argument('site', nargs='?', default="", help=SITE_HELP_SECTION)
    parser_7.set_defaults(command='list')

    parser_8 = subparsers.add_parser('status', help='show current status of clusters and all services')
    parser_8.add_argument('site', nargs='?', default="", help=SITE_HELP_SECTION)  # todo to update help
    parser_8.set_defaults(command='status')

    parser_9 = subparsers.add_parser('version', help='get current version')
    parser_9.set_defaults(command='version')

    return parser.parse_args(args=command_args)


def main(command_args=None):
    global args
    args = parse_command_line(command_args)

    # get version command
    if args.command in "version":
        with open('version', 'r') as f:
            print('SM-client %s' % f.read())
        exit(0)

    if not init_and_check_config(args):
        exit(1)

    ignored_services.extend(skip_services)

    if not run([i for i in run_services if i not in skip_services], args.command,
                args.site if hasattr(args, 'site') else False):
        exit(1)
    exit(0)

if __name__ == "__main__":
    main()
