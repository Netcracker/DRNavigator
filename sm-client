#!/usr/bin/env python3
"""
Company:     NetCracker 
Author:      Core PaaS Group
Version:     0.7
Date:        2021-11-19
Description: Client util to manage site-manager in kubernetes clusters
"""

import argparse
import json
import logging
import ssl
import threading
import time
from http import HTTPStatus

import yaml
import requests
import os

from requests.adapters import HTTPAdapter
from prettytable import PrettyTable
from typing import Tuple,Dict,Union
from urllib3 import Retry
from urllib3.exceptions import InsecureRequestWarning

MAIN_HELP_SECTION = """
Script to manage DR cases in kubernetes Active-Standby scheme

How to use commands:

  +------------------------------+        +------------------------------+
  |      INITIAL CONDITION       |        |        FINAL CONDITION       |
  +--------------+---------------+--------+--------------+---------------+-----+---------+
  | ACTIVE SITE  | STANDBY SITE  |  ===>  | ACTIVE SITE  | STANDBY SITE  |     | COMMAND |
  +--------------+---------------+  ===>  +--------------+---------------+     +---------+
  | ACTIVE       | STANDBY       |  ===>  | STANDBY      | ACTIVE        |  =  | move    |
  | failed       | STANDBY       |  ===>  | stopped      | ACTIVE        |  =  | stop    |
  | stopped      | ACTIVE        |  ===>  | STANDBY      | ACTIVE        |  =  | return  |
  | ACTIVE       | stopped       |  ===>  | ACTIVE       | STANDBY       |  =  | return  |
  | ACTIVE       | STANDBY       |  ===>  | ACTIVE       | stopped       |  =  | mntc    |
  +--------------+---------------+--------+--------------+---------------+-----+---------+
"""

SITE_HELP_SECTION = """define the cluster name.
This site:
  will be active in case of move 
  will be standby in case of stop
  will be standby in case of return
  will be disable to maintenance in case of mntc
"""

running_procedure = ""
running_services = []
done_services = []
ignored_services = []
failed_services = []
procedure_results = dict()

sm_conf={}

conf_parsed = None
testing_mode = None
site_names = None
SERVICE_DEFAULT_TIMEOUT = None

DR_cmds = ("move", "stop", "status", "list")
site_cmds = ("active", "standby", "return", "mntc", "status", "list")

run_services = None
skip_services = None

def config_checks_init(args) -> bool:
    """
    Main entry point. Provides validations, config parsing and initialization
    Returns:
        True of False
    """

    # Set verbosity for logging
    if args.verbose:
        logging_level = logging.DEBUG
        logging_format = "%(asctime)s [%(levelname)s] %(filename)s.%(funcName)s(%(lineno)d): %(message)s"
    else:
        logging_level = logging.INFO
        logging_format = "%(asctime)s [%(levelname)s] %(filename)s: %(message)s"

    logging.basicConfig(format=logging_format, level=logging_level)

    logging.debug(f"Script arguments: {args}")


    global conf_parsed
    # Define, check and load configuration file
    conf_file = os.path.join(os.path.dirname(os.path.abspath(__file__)), "config.yaml") if args.config == "" else args.config
    if not os.path.isfile(conf_file):
        logging.fatal("You should define configuration file for site-manager or copy it to config.yaml in site-manager main directory")
        exit(1)

    try:
        conf_parsed = yaml.load(open(conf_file), Loader=yaml.FullLoader)
    except:
        logging.fatal("Can not parse configuration file!")
        return False

    logging.debug(f"Parsed config: {conf_parsed}")

    global SM_HTTP_SECURE
    global FRONT_HTTP_AUTH

    global SM_HTTPS_SECURE
    SM_HTTPS_SECURE = not args.insecure

    FRONT_HTTP_AUTH = conf_parsed.get("sm-client", {}).get("http_auth", False)

    global SERVICE_DEFAULT_TIMEOUT
    SERVICE_DEFAULT_TIMEOUT = conf_parsed.get("sm-client", {}).get("service_default_timeout", 200)

    global testing_mode
    # Set testing mode for all procedures
    if "testing" in conf_parsed and conf_parsed["testing"].get("enabled", False) == True:
        testing_mode = True
    else:
        testing_mode = False

    global site_names
    site_names = [i["name"] for i in conf_parsed["sites"]]
    global run_services
    # Check services for running
    if args.run_services != '':
        run_services = args.run_services.replace(',', ' ').replace('  ', ' ').split(' ')
    else:
        run_services = []
    global skip_services
    if args.skip_services != '':
        skip_services = args.skip_services.replace(',', ' ').replace('  ', ' ').split(' ')
    else:
        skip_services = []

    for site in site_names:
        try:
            site_url = [ i["site-manager"] for i in conf_parsed["sites"] if i ["name"] == site ][0]
        except KeyError:
            logging.error("Check configuration file. Some of sites does not have 'site-manager' parameter")
            return False

        site_token = [ i.get("token", "") for i in conf_parsed["sites"] if i ["name"] == site ][0]
        site_cacert = [ i.get("cacert", True) for i in conf_parsed["sites"] if i ["name"] == site ][0]

        if site_cacert != True and not os.path.isfile(site_cacert):
            logging.fatal(f"You should define correct path to CA certificate for site {site}")
            return False
        global sm_conf
        sm_conf[site] = {}
        sm_conf[site]["url"] = site_url
        sm_conf[site]["token"] = site_token
        sm_conf[site]["cacert"] = SM_HTTPS_SECURE if not SM_HTTPS_SECURE else site_cacert

    return True

def main(sm_conf, services="", cmd="",args="",site=""):
    sm_dict = {"sites":{}}

    for site in sm_conf.keys():
        sm_dict["sites"][site]={}
        sm_dict["sites"][site]["status"] = False # True - site is fully OK or io_http_json_request return code in case error
        response, code = service_process(site,"site-manager","status")
        if "services" in response and code:
            sm_dict["sites"][site]["status"] = True
        else:
            logging.error(f"Site {site} does not return valid response. Error code:", code)
            sm_dict["sites"][site]["status"] = code

        sm_dict["sites"][site].update(response)
    print(json.dumps(sm_dict))

    # assemble ordered service list keeping in services list specified in cli
    service_dep_ordered,_ = make_ordered_services(sm_dict, services)

    #  validation to satisfy cmd and current site status
    if not validate_operation(sm_dict,service_dep_ordered,cmd,args,site):
        exit(False)

    if cmd in site_cmds and site:  # per site command
        for serv in service_dep_ordered:
            service_process_status_polling(site,serv,convert_cmd_to_procedure(cmd),sm_dict) # run in Thread
            #thread.join
        print_main_table()
    elif cmd in DR_cmds :  # DR command, both sites
        # handle each DR command
        if cmd in ("list", "status"):
            print_main_table(service_dep_ordered, cmd)
        elif cmd in ("move", "stop"):
            for serv in service_dep_ordered:
                for site_process, mode in get_sequence(sm_dict,serv,cmd,site):
                    service_process_status_polling(site_process,serv,mode,sm_dict) # run in Thread
            # thread.join
            print_main_table()
    return

def get_sequence(sm_dict,serv,cmd,site) -> [[],[]]: # move active, stop standby
    """
    Get DR operation(cmd) site sequence for specific service
    Return:
        [['site1','standby'],['site2','active']]
    """
    opposite_site = None
    for s in sm_dict['sites'].keys():
        if s != site:
            opposite_site = s

    if cmd == 'move': #switchover
        mode = sm_dict['sites'][site]['services'][serv]['sequence'][0]
        if mode == 'standby':
            site_sequence=[[opposite_site,'standby'],[site,'active']]
        elif mode == 'active':
            site_sequence = [[site,'active'],[opposite_site,'standby']]
    elif cmd == 'stop': #failover
        mode = sm_dict['sites'][opposite_site]['services'][serv]['sequence'][0]
        if mode == 'standby':
            site_sequence = [[site,'standby'],[opposite_site,'active']]
        elif mode == 'active':
            site_sequence = [[opposite_site,'active'],[site,'standby']]
    else:
        return False

    return site_sequence

def make_ordered_services(sm_dict,services_to_process=[]) -> Tuple[list,bool]:
    """
    Make ordered and validated services list from all sites in sm_dict
    TODO validate same services on both sides
        before , after params are the same and exists
        leave only service presented on all sites
    """

    def after_sort(ll: list) -> [list,list]:
        """
        Sort service list using AFTER dependency
        ll = m=[{'a':{'after':['e']}},
                {'b':{'after':['z']}},
        TODO list consistency validation
         before procedure support
         multiple dependency service support
        Return:
            list of sorted list
            list of services with non exist deps [[service, wrong_dep]]
        """
        sorted_list = [ list(i.keys())[0] for i in ll ]  # make a list to be sorted
        wrong_dep_list = []
        for i in ll:
            if i[list(i.keys())[0]]['after'] and \
                    i[list(i.keys())[0]]['after'][0] in sorted_list: # if after not empty put i item AFTER dependant item
                sorted_list.insert(sorted_list.index(i[list(i.keys())[0] ]['after'][0]) + 1,
                                   sorted_list.pop(sorted_list.index(list(i.keys())[0])))
            elif i[list(i.keys())[0]]['after'] and \
                    i[list(i.keys())[0]]['after'][0] not in sorted_list: #if wrong dep - collect them
                wrong_dep_list.append([list(i.keys()),i[list(i.keys())[0]]['after']])
        return sorted_list, wrong_dep_list

    temp_dict = sm_dict.copy()

    # leave only service listed in service_to_process
    for site in temp_dict[ 'sites' ]:
        for serv in temp_dict[ 'sites' ][ site ][ 'services' ].copy().keys():
            if services_to_process and serv not in services_to_process:
                temp_dict['sites'][site]['services'].pop(serv,None)


    #collect sorted ordered service list from both sites
    service_lists = {}
    for site in temp_dict['sites']:
        service_lists[site],wrong_dep_list =  after_sort([ {serv:{'after':value['after']} } for serv,value in
                            temp_dict['sites'][site]['services'].items() ])
        for i in wrong_dep_list:
            print(f"Site: {site}. Service: {i[0]}. Service has nonexistent dependencies: {i[1]}")

    # compare service lists
    equal_list = True
    for i in range(len(service_lists.keys()) - 1):
        if list(service_lists.values())[i] != list(service_lists.values())[i+1]:
            equal_list = False

    #check services equality on all sites
    if equal_list:
        return list(service_lists.values())[0], True
    else: #TODO to rework intersect in general manner(several sites support) with comprehensive warning
        print("The service lists are different on sites:", \
              list(service_lists.values())[0], list(service_lists.values())[1])
        return list(set(set(list(service_lists.values())[1]). #return intersect from both lists
                        intersection(set(list(service_lists.values())[0])))), False

def validate_operation(sm_dict, service_dep_ordered, cmd, args, site) -> bool:
    """
    Validate procedure
    """
    for site in sm_dict['sites'].keys():
        if not sm_dict['sites'][site]['status'] and site:
            logging.error("Site: ",site," is not available")
            return False
    return True

def io_http_json_request(url, token="", verify=True, http_body={}, retry=3) -> Tuple[Dict, int]:
    """
    Sends GET/POST request to service
    :param string url: the URL to service operator
    :param token: Bearer toke
    :param verify: Server side SSL verification
    :param retry: the number of retries
    :param http_body: the dictionary with procedure and list of services
    :returns:
    :Dict not empty json body in case Ok
    :HTTP_CODE or
    :False in case not http request issue
    :IO SSL codes ssl.SSLErrorNumber.SSL_ERROR_SSL SSLErrorNumber.SSL_ERROR_EOF
    """
    if(os.getenv("DEBUG")):
        # Disable warnings about self-signed certificates from requests library
        requests.packages.urllib3.disable_warnings(InsecureRequestWarning)

    if token != "" and FRONT_HTTP_AUTH:
        headers = {"Authorization": f"Bearer {token}"}
    else:
        headers = {}

    logging.debug(f"REST url: {url}")
    logging.debug(f"REST data: {http_body}")
    logging.debug(f"REST headers: {headers}")

    session = requests.Session()
    retries = Retry(total=retry)
    session.mount('https://', HTTPAdapter(max_retries=retries))
    session.mount('http://', HTTPAdapter(max_retries=retries))

    logging.getLogger("urllib3").setLevel(logging.CRITICAL)

    try:
        if any(http_body):
            resp = session.post(url, json=http_body, timeout=30, headers=headers, verify=verify)
        else:
            resp = session.get(url, timeout=5, headers=headers, verify=verify)

        return resp.json() if resp.json() else {},resp.status_code # return ANY content with HTTP code

    except requests.exceptions.SSLError as e:
        logging.error("SSL certificate verify failed")
        logging.error("Please use key -k or --insecure")
        #TODO in more accurate manner error handling manner
        if "SSLCertVerificationError" in str(e.args): ## SSL Verification fails ; SSLCertVerificationError(1, '[SSL: CERTIFICATE_VERIFY_FAILED] certificate verify failed: unable to get local issuer certificate (_ssl.c:1125)')
            return {}, ssl.SSLErrorNumber.SSL_ERROR_SSL.__int__() # - 1
        elif "SSLEOFError" in str(e.args): # SSL connect error, SSL resource is not accessible vi ha-proxy  ; SSLEOFError(8, 'EOF occurred in violation of protocol (_ssl.c:1091)')
            #TODO need a test for this case
            return {}, ssl.SSLErrorNumber.SSL_ERROR_EOF.__int__() # - 8
    except requests.exceptions.JSONDecodeError:
        logging.error("Wrong JSON data received")
    except requests.exceptions.RequestException as e:
        logging.error("General request error %s",e.__doc__)
    except Exception as e :
        logging.error("General error %s",e.__doc__)

    return {}, False

def convert_cmd_to_procedure(site_cmd):
    """
    Converts <site_cmd> (DR_cmds,site_cmds) into service JSON <procedure>
    @param site_cmd:
    @return: procedure
    """
    if site_cmd in ["status","list"]:
        return "status"
    elif site_cmd == "mntc":
        return  "disable"
    elif site_cmd == "return":
        return  "standby"
    elif site_cmd in ["active","standby"]:
        return site_cmd
    else:
        return False

def service_process(site,service,site_cmd: str,no_wait=False,force=False) -> Tuple[Dict,bool]:
    """
    Processes the service with specific site cmd
    """
    global sm_conf

    if site_cmd in ["status","list"]:  # RO operations
        body = {} if service == "site-manager" else {"procedure": "status", "run-services": [service]}
    else:
        body = {"procedure": convert_cmd_to_procedure(site_cmd), "run-services": [service], "no-wait": no_wait, "force": force}

    response, return_code = io_http_json_request(sm_conf[site]["url"],
                                              sm_conf[site]["token"],
                                              sm_conf[site]["cacert"],
                                              body)
    return response,True if return_code == HTTPStatus.OK else return_code

def service_process_status_polling(site,service,mode,sm_dict) -> Tuple[Dict,bool]:
    """

    @param site:
    @param service:
    @param site_cmd:
    @param no_wait:
    @param force:
    @return:
    """
    def service_status_polling(site,service,state,timeout=SERVICE_DEFAULT_TIMEOUT,delay=5) -> Tuple[Dict,bool]:
        """
        Polls "site-manager status" <service> command till <state> dict returns during <timeout> period
        with <delay>
        :param dict state: {"status": ["up"]} - expected dict state from site-manager service status command
        """

        key = list(state.keys())[0]
        value = list(state.values())[0]
        init_time = int(time.time())

        count = 0
        while int(time.time()) < init_time + int(timeout):
            count += 1

            logging.info(f"Service: {service}. Site: {site}. Polling procedure {key} Iteration {count}")
            logging.info(f"Service: {service}. Site: {site}. {int(timeout) - (int(time.time()) - init_time)} seconds left until timeout")

            data,ret = service_process(site,"site-manager","status")

            logging.debug(f"Service: {service}. Site: {site}. Received data: {data}. Return code: {ret}")

            if ret and data["services"][service][key] in value:
                return data
            else:
                time.sleep(delay)
                continue

    service_process(site,service,mode)  # run in Thread
    service_status_polling(site,service,{"status":["done"]})
    data, ret = service_status_polling(site,service,{"mode":[mode]})
    if mode == "active":
        data, ret = service_status_polling(site,service,{"healthz":["up"]})
    elif mode == "standby":
        data, ret = service_status_polling(site,service,{"healthz": \
                                                              sm_dict["sites"][site]["services"][service]["allowedStandbyStateList"]})
    else:
        data,ret=service_status_polling(site,service,{"healthz": ["down"]})

    if data["services"][service].get("mode","--") == "--" or \
            data["services"][service].get("status","--") == "--":
        return {"mode": "unknown", "status": "unknown", "healthz": "--"},False
    return data,ret

def make_table(header, sites_name):
    """
    Method for creating the main parts of the table
    """

    pt = PrettyTable()
    pt_field_names = ["Service"]

    for sites_item in sites_name:
        pt_field_names.append(f"{sites_item}")

    pt.field_names = pt_field_names
    pt.align["Service"] = "l"

    # Additional header
    comment_pt_row = [""]
    separator_pt_row = ["--------------------------"]

    for sites_item in sites_name:
        comment_pt_row.append(header)
        separator_pt_row.append("--------------------------")

    pt.add_row(comment_pt_row)
    pt.add_row(separator_pt_row)

    return pt

def print_main_table(status_dict, services_to_run, sites_name):
    """
    Method intended to display section `additional` from the site-manager response, if any

    :param dict status_dict: the results of the procedure received from the site-manager
    :param list services_to_run: the list of services that have been processed
    :param list sites_name: list of cluster names
    """

    pt = make_table("mode | DR status | healthz", sites_name)
    for service_item in services_to_run:
        service_pt_row = list()
        service_pt_row.append(service_item)

        for sites_item in sites_name:
            service_pt_row.append(
                f"{status_dict[service_item][sites_item]['mode']} / {status_dict[service_item][sites_item]['status']} / {status_dict[service_item][sites_item]['healthz']}")
        pt.add_row(service_pt_row)

    pt.sortby = "Service"

    print(pt)

def print_additional_table(status_dict, services_to_run, sites_name):
    """
    Method intended to display section `additional` from the site-manager response, if any

    :param dict status_dict: the results of the procedure received from the site-manager
    :param list services_to_run: the list of services that have been processed
    :param list sites_name: list of cluster names
    """

    pt = make_table('additional', sites_name)
    is_any_additional = False

    for service_item in services_to_run:
        service_pt_row = list()
        service_pt_row.append(service_item)
        for sites_item in sites_name:
            additional = ""
            for item in status_dict[service_item][sites_item].get('additional', dict()):
                for key, value in status_dict[service_item][sites_item]["additional"][item].items():
                    additional = additional + str(key) + ": \n" + str(value) + " \n"
            if additional:
                service_pt_row.append(f"{additional}")
            else:
                for sites_item in sites_name:
                    if any(status_dict[service_item][sites_item].get('additional', dict())):
                        service_pt_row.append("--")
        if len(service_pt_row) > 1:
            pt.add_row(service_pt_row)
            is_any_additional = True

    pt.sortby = "Service"
    if is_any_additional:
        print(pt)

if __name__ == "__main__":
    # Main argument parser
    parser = argparse.ArgumentParser(description=MAIN_HELP_SECTION,
                                     argument_default=argparse.SUPPRESS,
                                     formatter_class=argparse.RawTextHelpFormatter)

    parser.add_argument('-v', '--verbose', default=False, action='store_true', help='enable the verbosity mode')
    parser.add_argument('-c', '--config', default="", help='define the path to configuration file')
    parser.add_argument('-f', '--force', default=False, action='store_true', help='force apply DR action and ignore healthz')
    parser.add_argument('-k', '--insecure', default=False, action='store_true', help='enable self-signed certificates')
    parser.add_argument('--run-services', default='', help='define the list of services to apply DR action, by default all services participate')
    parser.add_argument('--skip-services',  default='', help='define the list of services what will not participate in DR action')

    subparsers = parser.add_subparsers()

    parser_1 = subparsers.add_parser('move', help='move Active functionality to Standby site')  # DR switchover
    parser_1.add_argument('site', help=SITE_HELP_SECTION)
    parser_1.set_defaults(command='move')

    parser_2 = subparsers.add_parser('stop', help='excludes site from Active-Standby scheme')  # DR failover
    parser_2.add_argument('site', help=SITE_HELP_SECTION)
    parser_2.set_defaults(command='stop')

    parser_3 = subparsers.add_parser('return', help='return stopped Kubernetes cluster to Standby role')
    parser_3.add_argument('site', help=SITE_HELP_SECTION)
    parser_3.set_defaults(command='return')

    parser_4 = subparsers.add_parser('mntc', help='stop Standby kubernetes cluster for maintenance')
    parser_4.add_argument('site', help=SITE_HELP_SECTION)
    parser_4.set_defaults(command='mntc')

    parser_5 = subparsers.add_parser('active', help='set kubernetes cluster services to active mode')
    parser_5.add_argument('site', help=SITE_HELP_SECTION)
    parser_5.set_defaults(command='active')

    parser_6 = subparsers.add_parser('standby', help='set kubernetes cluster services to standby mode')
    parser_6.add_argument('site', help=SITE_HELP_SECTION)
    parser_6.set_defaults(command='standby')

    parser_7 = subparsers.add_parser('list', help='list all services from Active-Standby scheme managed by site-manager with dependencies')
    parser_7.set_defaults(command='list')

    parser_8 = subparsers.add_parser('status', help='show current status of clusters and all services')
    parser_8.set_defaults(command='status')

    parser_9 = subparsers.add_parser('daemon', help='run site-manager as a service')
    parser_9.set_defaults(command='daemon')

    args = parser.parse_args()

    if not config_checks_init(args):
        exit(False)
    main(sm_conf, [i for i in run_services if i not in skip_services], args.command, args, args.site)
