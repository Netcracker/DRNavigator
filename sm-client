#!/usr/bin/env python3.9
"""
Company:     NetCracker 
Author:      Core PaaS Group
Version:     0.7
Date:        2021-11-19
Description: Client util to communicate with site-manager in kubernetes based clusters
@todo[3]
    split current single source into modules,classes
    share common code with sm
    make smclient delivery as single binary, using pyinstaller ???
    json output
    SM specific data structures: sm_dict; service response
"""

import argparse
import copy
import logging
import ssl
import threading
import time
from graphlib import TopologicalSorter, CycleError
from http import HTTPStatus
from queue import Queue

import yaml
import requests.packages
import os

from requests.adapters import HTTPAdapter
from prettytable import PrettyTable
from typing import Tuple, Dict, Optional
from urllib3 import Retry
from urllib3.exceptions import InsecureRequestWarning

MAIN_HELP_SECTION = """
Script to manage DR cases in kubernetes Active-Standby scheme

How to use commands:

  +------------------------------+        +------------------------------+
  |      INITIAL CONDITION       |        |        FINAL CONDITION       |
  +--------------+---------------+--------+--------------+---------------+-----+---------+
  | ACTIVE SITE  | STANDBY SITE  |  ===>  | ACTIVE SITE  | STANDBY SITE  |     | COMMAND |
  +--------------+---------------+  ===>  +--------------+---------------+     +---------+
  | ACTIVE       | STANDBY       |  ===>  | STANDBY      | ACTIVE        |  =  | move    |
  | failed       | STANDBY       |  ===>  | stopped      | ACTIVE        |  =  | stop    |
  | stopped      | ACTIVE        |  ===>  | STANDBY      | ACTIVE        |  =  | return  |
  | ACTIVE       | stopped       |  ===>  | ACTIVE       | STANDBY       |  =  | return  |
  | ACTIVE       | STANDBY       |  ===>  | ACTIVE       | stopped       |  =  | mntc    |
  +--------------+---------------+--------+--------------+---------------+-----+---------+
"""
SITE_HELP_SECTION = """define the cluster name.
This site:
  will be active in case of move 
  will be standby in case of stop
  will be standby in case of return
  will be disable to maintenance in case of mntc
"""

done_services = []
ignored_services = []
failed_services = []

sm_conf = {}  # global config.yaml and some RO config parameters
args = None

SERVICE_DEFAULT_TIMEOUT = None
thread_result_queue = Queue(maxsize=-1)

ReadOnly_cmd = ("status","list")
DR_procedures = ("move", "stop") + ReadOnly_cmd  # DR procedures: switchover, failover
site_cmds = ("active", "standby", "return", "mntc") + ReadOnly_cmd  # per site commands

run_services = []
skip_services = []


def init_and_check_config(args) -> bool:
    """ Main entry point. Provides validations, config parsing and initialization
    @returns: True of False  """
    #TODO python version check
    #sys.version_info
    #sys.version_info(major=3, minor=9, micro=13, releaselevel='final', serial=0)

    # Set verbosity for logging
    if args.verbose:
        logging_level = logging.DEBUG
        logging_format = "%(asctime)s [%(levelname)s] %(filename)s.%(funcName)s(%(lineno)d): %(message)s"
    else:
        logging_level = logging.INFO
        logging_format = "%(asctime)s [%(levelname)s] %(filename)s: %(message)s"

    logging.basicConfig(format=logging_format, level=logging_level)

    logging.debug(f"Script arguments: {args}")

    # Define, check and load configuration file
    conf_file = os.path.join(os.path.dirname(os.path.abspath(__file__)), "config.yaml") if args.config == "" else args.config
    if not os.path.isfile(conf_file):
        logging.fatal("You should define configuration file for site-manager or copy it to config.yaml in site-manager main directory")
        exit(1)

    try:
        conf_parsed = yaml.load(open(conf_file), Loader=yaml.FullLoader)
    except:
        logging.fatal("Can not parse configuration file!")
        return False

    logging.debug(f"Parsed config: {conf_parsed}")

    global FRONT_HTTP_AUTH
    FRONT_HTTP_AUTH = conf_parsed.get("sm-client", {}).get("http_auth", False)

    global SERVICE_DEFAULT_TIMEOUT
    SERVICE_DEFAULT_TIMEOUT = conf_parsed.get("sm-client", {}).get("service_default_timeout", 200)

    global run_services
    # Check services for running
    if args.run_services != '':
        run_services = args.run_services.replace(',', ' ').replace('  ', ' ').split(' ')

    global skip_services
    if args.skip_services != '':
        skip_services = args.skip_services.replace(',', ' ').replace('  ', ' ').split(' ')

    site_names = [i["name"] for i in conf_parsed["sites"]]
    for site in site_names:
        try:
            site_url = [ i["site-manager"] for i in conf_parsed["sites"] if i ["name"] == site ][0]
        except KeyError:
            logging.error("Check configuration file. Some of sites does not have 'site-manager' parameter")
            return False

        site_token = [ i.get("token", "") for i in conf_parsed["sites"] if i ["name"] == site ][0]
        site_cacert = [ i.get("cacert", True) for i in conf_parsed["sites"] if i ["name"] == site ][0]

        if site_cacert != True and not os.path.isfile(site_cacert):
            logging.fatal(f"You should define correct path to CA certificate for site {site}")
            return False
        global sm_conf
        sm_conf[site] = {}
        sm_conf[site]["url"] = site_url
        sm_conf[site]["token"] = site_token
        sm_conf[site]["cacert"] = False if args.insecure else site_cacert

    return True


def sm_get_cluster_state(site=None) -> dict:
    """ Get cluster status or per specific site and init sm_dict
    """
    global sm_conf
    sm_dict={"sites":{}}
    sites = [s for s in sm_conf.keys() if site == s ] if site else sm_conf.keys()
    for site_name in sites:
        sm_dict["sites"][site_name]={}
        sm_dict["sites"][site_name]["status"] = False # True - site is fully OK or io_http_json_request return code in case error
        sm_dict["sites"][site_name]["services"] = {}
        response, ret, code = sm_process_service(site_name, "site-manager", "status")
        sm_dict["sites"][site_name]["return_code"] = code # HTTP or SSL
        sm_dict["sites"][site_name]["status"] = ret

        sm_dict["sites"][site_name].update(response)
    return sm_dict


def data_make_ignored_services(sm_dict:dict, service_dep_ordered: list) -> []:
    """ Make list of services which are not intended to run, ignored."""
    ignored_list = []
    for site in sm_dict['sites']:
        for serv in sm_dict['sites'][site]['services'].keys():
            if serv not in service_dep_ordered:
                ignored_list.append(serv)
    return list(set(ignored_list))


def data_get_available_sites(sm_dict:dict) -> []:
    """ Return list of available sites """
    return [site for site in sm_dict['sites'].keys() if sm_dict['sites'][site]['status']]


def sm_process_service_with_polling(site, service, cmd, sm_dict) -> None:
    global thread_result_queue

    if service in "cluster-replicator":  # replicator WA todo replicator
        thread_result_queue.put(service)
        logging.debug(f"Skipping {service} in thread")
        return

    if cmd in site_cmds:
        mode=data_convert_sitecmd_to_dr_mode(cmd)
        sm_process_service(site, service, mode)
        data_sortout_service_results(sm_poll_service_required_status(site, service, mode, sm_dict))
    elif cmd in DR_procedures:
        for site_to_process, mode in data_get_dr_operation_sequence(sm_dict, service, cmd, site):
            if cmd == "stop" and mode == "standby":
                force = True
                logging.info(f"Force key enabled for procedure 'stop' for service {service} on passivated site")
            else:
                force = args.force
            sm_process_service(site_to_process, service, mode)
            data_sortout_service_results(sm_poll_service_required_status(site_to_process, service, mode, sm_dict), force)

    thread_result_queue.put(service)
    logging.info(f"Processing {service} in thread")


def main(services:[] = None, cmd="", site="", cli_args: argparse.Namespace = None):
    """ Business Logic - implements main flow """

    # get status for all sites in case DR procedure or specific site in case cmd
    sm_dict = sm_get_cluster_state(site if cmd in site_cmds and site else None)

    # assemble ordered service list to proceed, keeping in services specified in cli
    service_dep_ordered,return_code, ts = make_ordered_services_to_process(sm_dict, services)

    #  validation to satisfy cmd and current site status
    if not validate_operation(sm_dict, (service_dep_ordered,return_code), cmd, site, services):
        exit(1)

    ignored_services.extend(data_make_ignored_services(sm_dict, service_dep_ordered))
    thread_pool = []
    if cmd in ("status"):
        for serv in service_dep_ordered:
            for site_i in data_get_available_sites(sm_dict):
                def run_in_thread(site, serv, sm_dict):  # to run each status service in parallel
                    response, ret, _ = sm_process_service(site, serv, "status")
                    sm_dict['sites'][site]['services'][serv]['status']=response['services'][serv] if ret else False
                thread=threading.Thread(target=run_in_thread, args=(site_i, serv, sm_dict))
                thread.name=f"Thread: {serv}"
                thread.start()
                thread_pool.append(thread)
        for thread in thread_pool:
            thread.join()
        print_main_table(sm_dict, service_dep_ordered, [site] if site else [_ for _ in sm_conf.keys()])
    elif cmd in ("list"):
        print(f"---------------------------------------------------------------------\n" +
              f"Sites managed by site-manager:               {[site for site in sm_dict['sites'].keys()]}\n\n" +
              f"Kubernetes services managed by site-manager: {data_get_services_list_for_ok_site(sm_dict)}\n" +
              f"Kubernetes services that will be processed:  {service_dep_ordered}\n" +
              f"---------------------------------------------------------------------")
    elif cmd in site_cmds + DR_procedures :  # per site command or DR procedure
        print_service_operation_summary("top", sm_dict, service_dep_ordered, cmd, site)

        if "cluster-replicator" in service_dep_ordered: #replicator WA @todo replicator
            if cmd == "standby":
                sm_process_replicator(sm_dict, [site, data_convert_sitecmd_to_dr_mode(cmd)])
            elif cmd in DR_procedures:
                sm_process_replicator(sm_dict, data_get_dr_operation_sequence(sm_dict, "cluster-replicator", cmd, site)[0])

            if "cluster-replicator" in failed_services:
                logging.error(f"cluster-replicator failed, skipping rest of services, exiting")
                exit(1)

        while ts and ts.is_active():
            for serv in ts.get_ready():
                thread=threading.Thread(target=sm_process_service_with_polling,
                                        args=(site, serv, cmd, sm_dict))
                thread.name=f"Thread: {serv}"
                thread_pool.append(thread)
                thread.start()
            global thread_result_queue
            serv_done = thread_result_queue.get()
            if serv_done in failed_services: # mark failed and skip successors of serv_done
                for s in ts.successors(serv_done):
                    ts.done(s)
                    failed_services.append(s)
            ts.done(serv_done)
        for thread in thread_pool:
            thread.join()

        if "cluster-replicator" in service_dep_ordered: #replicator WA @todo replicator
            if len(failed_services) != 0:  #ignore running replicator in case failed infra
                ignored_services.append("cluster-replicator")
            else:
                if cmd == "active":
                    sm_process_replicator(sm_dict, [site, data_convert_sitecmd_to_dr_mode(cmd)])
                elif cmd in DR_procedures:
                    sm_process_replicator(sm_dict, data_get_dr_operation_sequence(sm_dict, "cluster-replicator", cmd, site)[1])

        print_service_operation_summary("tail",sm_dict, service_dep_ordered, cmd, site )
    else:
        logging.error(f"Unknown combination of {cmd} {site} options")
        exit(1)

    if len(failed_services) != 0:
        logging.fatal(f"Some services finished {cmd} with failed status")
        exit(1)

    return True


class TopologicalSorter2(TopologicalSorter):
    """ added method to get successors of specific node """
    def successors(self, node):
        for i in self._node2info.values():
            if i.node == node:
                return i.successors
        return None


def sm_process_replicator(sm_dict,site_mode: []):   #@todo replicator
    """ Process replicator in blocking mode"""
    logging.debug(f"Processing replicator service on site:{site_mode[0]} to mode:{site_mode[1]}")
    sm_process_service(site_mode[0], "cluster-replicator", site_mode[1])
    data_sortout_service_results(sm_poll_service_required_status(site_mode[0], "cluster-replicator", site_mode[1], sm_dict))


def data_sortout_service_results(result: Tuple[dict, bool], force: bool = False):
    """ Put service name in appropriate list(failed or done)
    @param result: Tuple[json response dict, return code]
    @param force: True/False --force mode to ignore healthz
    """
    service = list(result[0]['services'].keys())[0]
    if result[1] or (not result[1] and force ): #return Ok , or --force enabled - done_service
        done_services.append(service)
        failed_services.remove(service) if service in failed_services else None
    else:
        failed_services.append(service)
        done_services.remove(service) if service in done_services else None

    if not result[1] and force:
        logging.warning(f"Service: {service}. Force mode enabled. Service healthz ignored")


def print_service_operation_summary(part, sm_dict, services_to_run: [], cmd="", site="", ):
    def get_sm_managed_services(sm_dict):
        final_set = set()
        for site in sm_dict["sites"].values():
            final_set=final_set.union(set(list(site['services'].keys())))
        return list(final_set)

    def get_active_site(sm_dict, cmd, site):
        if cmd in ["active", "move"]:
            return site
        elif cmd in ["stop", "standby"]:
            return data_get_opposite_site(sm_dict, site)
        else:
            return None
    if part in "top":
        logging.info("---------------------------------------------------------------------")
        logging.info(f"Procedure:     {cmd}")
        logging.info(f"Active sites:  {get_active_site(sm_dict, cmd, site)}")
        logging.info(f"Standby sites: {data_get_opposite_site(sm_dict, get_active_site(sm_dict, cmd, site))}")
        logging.info(f"Kubernetes services managed by site-manager: {get_sm_managed_services(sm_dict)}")
        logging.info(f"Kubernetes services that will be processed:  {services_to_run}")
        logging.info("---------------------------------------------------------------------")
    elif part in "tail":
        logging.info("---------------------------------------------------------------------")
        logging.info("Summary:")
        logging.info(f"services that successfully done: {list(dict.fromkeys(done_services))}")
        logging.info(f"services that failed:            {failed_services}")
        logging.info(f"services that ignored:           {ignored_services}")
        logging.info("---------------------------------------------------------------------")


def data_get_services_list_for_ok_site(sm_dict) ->[]:
    for site in sm_dict['sites'].keys():
        if sm_dict["sites"][site]["status"]:
            return [ serv for serv in sm_dict["sites"][site]["services"].keys()]
    return []


def data_get_opposite_site(sm_dict, site):
    opposite_site = None
    for s in sm_dict['sites'].keys():
        if s != site:
            opposite_site = s
    return opposite_site


def data_get_dr_operation_sequence(sm_dict, serv, procedure, site) -> [[], []]: # move active, stop standby
    """ Get DR operation(cmd) site sequence in the correct order for specific service for provided DR procedure
    @returns: [['site1','standby'],['site2','active']]
    """
    opposite_site = data_get_opposite_site(sm_dict, site)
    site_sequence = []
    if procedure == 'move': #switchover
        mode = sm_dict['sites'][site]['services'][serv]['sequence'][0]
        if mode == 'standby':
            site_sequence=[[opposite_site,'standby'],[site,'active']]
        elif mode == 'active':
            site_sequence = [[site,'active'],[opposite_site,'standby']]
    elif procedure == 'stop': #failover
        mode = sm_dict['sites'][opposite_site]['services'][serv]['sequence'][0]
        if mode == 'standby':
            site_sequence = [[site,'standby'],[opposite_site,'active']]
        elif mode == 'active':
            site_sequence = [[opposite_site,'active'],[site,'standby']]
    else:
        return False

    return site_sequence


def make_ordered_services_to_process(sm_dict: dict, services_to_process: list = None ) -> Tuple[list, bool, Optional[TopologicalSorter2]]:
    """ Make ordered and validated services list from all sites in sm_dict
    @returns: ordered list or empty if not possible to assemble(integrity issue), True or False  in case minor issue
        TopologicalSorter object in case success
    @todo[3]: cross site validation
    """
    def build_after_before_graph(dep_list: dict) -> TopologicalSorter2:
        """Assemble directed graph using AFTER and BEFORE dependency
        @param dep_list:[]: services list with deps in special format, see @note
        @returns: TopologicalSorter graph
        @todo: [3] multiple dependency service support
        @note:  format of input list  [{'serv2':{'after':['serv1'],'before':['serv3']}},...]
        """
        ts=TopologicalSorter2()
        for item in dep_list.keys():
            ts.add(item)
            if dep_list[item].get('after') and dep_list[item]['after'][0] in [ii for ii in dep_list.keys()]:
                ts.add(item, dep_list[item]['after'][0]) #if dep[AFTER,BEFORE] is present and exist in the dep_list - add it
            if dep_list[item].get('before') and dep_list[item]['before'][0] in [ii for ii in dep_list.keys()]:
                ts.add(dep_list[item]['before'][0], item)
        return ts
    def after_before_check(ll: dict) -> {}:
        """ Check AFTER and BEFORE dependency integrity
        @returns: dict of services if any with non exist deps , see format in @note
        @note: the return dict format {service:{'before':wrong_dep}}}
        """
        wrong_dep_list={}
        for i in ll.keys():
            if ll[i]['after'] and  ll[i]['after'][0] not in [ii for ii in ll.keys()]: #if wrong dep - collect them
                if not wrong_dep_list.get(i):
                    wrong_dep_list[i]={}
                wrong_dep_list[i]['after'] = ll[i]['after']

            if ll[i]['before'] and ll[i]['before'][0] not in [ii for ii in ll.keys()]: #if wrong dep - collect them
                if not wrong_dep_list.get(i):
                    wrong_dep_list[i]={}
                wrong_dep_list[i]['before'] = ll[i]['before']

        return wrong_dep_list

    ret = True
    integrity_error = False
    temp_dict = copy.deepcopy(sm_dict)

    # leave only service listed in service_to_process
    for site in temp_dict['sites']:
        for serv in temp_dict['sites'][site]['services'].copy().keys():
            if services_to_process and serv not in services_to_process:
                temp_dict['sites'][site]['services'].pop(serv,None)

    # collect sorted ordered service list
    service_lists = {}
    for site in temp_dict['sites']:
        try:
            service_lists[site] = [i for i in build_after_before_graph(temp_dict['sites'][site]['services']).static_order()]
            for service, depends in after_before_check(temp_dict['sites'][site]['services']).items():  # check deps
                for depend in depends:
                    logging.warning(f"Site: {site}. Service: {service} has nonexistent "
                                    f"{depend} dependency: {depends[depend]}")
                    ret = False
        except CycleError as e:
            logging.error(f"Site {site} has integrity issues: %s",e)
            integrity_error = True

    if integrity_error:
        return [], False, type(None) # return error, integrity issue

    # compare service lists when two sites are ready only
    equal_list = True
    for i in range(len(service_lists.keys()) - 1):
        if list(service_lists.values())[i] != list(service_lists.values())[i+1] and \
                all([sm_dict['sites'][site]['status'] for site in sm_dict['sites'].keys()]):
            equal_list = False

    # check services equality on all sites
    if equal_list:
        ts = build_after_before_graph(temp_dict['sites'][list(temp_dict['sites'].keys())[0]]['services'])
        ts.prepare()
        return list(list(service_lists.values())[0]), ret, ts
    else:
        logging.warning(f"The service lists are different on sites: " 
                        f"{list(service_lists.values())[0]} {list(service_lists.values())[1]} ")
        return [], False, None #todo[1] might be diff list on both, how to show status/list/move ?


def validate_operation(sm_dict:dict, service_dep_ordered: Tuple, cmd, site, services_to_run:[]=None) -> bool:
    """ Validate command compliance to current site state
    @param service_dep_ordered:
    @param sm_dict: populated sm_dict
    @returns: Allowed or not to proceed operation
    """
    def check_site_ssl_available(checked_site: str):
        if not sm_dict['sites'][checked_site]['status']:
            logging.error(f"Site: {checked_site} is not available")
            if sm_dict['sites'][checked_site]['return_code'] == ssl.SSLErrorNumber.SSL_ERROR_SSL.__int__():
                logging.error(f"SSL certificate verify failed for site:{checked_site}. Please use key -k or --insecure")
            return False
        return True
    global sm_conf
    #check site availability
    if cmd == "stop":
        ret = check_site_ssl_available(data_get_opposite_site(sm_dict, site))
    elif cmd == "move":
        ret = all(check_site_ssl_available(site) for site in sm_conf.keys())
    elif cmd in ["status","list"]: # for DR check both, for cmd only site
        ret = any([check_site_ssl_available(site)] if site else
                  [check_site_ssl_available(s) for s in sm_conf.keys()])
    else:
        ret = check_site_ssl_available(site)

    if not ret:
        return False

    # warn about absent --run-service
    for s in services_to_run if services_to_run else []:
        for site_i in [data_get_opposite_site(sm_dict, site) if cmd in "stop" else site] \
                if site else sm_dict["sites"].keys():
            if s not in sm_dict["sites"][site_i]["services"].keys():
                logging.warning(f"Service {s} does not exist in {site_i} kubernetes cluster")

    # check dependency issues for switchover
    if cmd in "move" and not service_dep_ordered[1]:
        logging.critical("Not able to perform 'move' operation because of dependency issues")
        return False

    return True


def io_make_http_json_request(url="", token="", verify=True, http_body:dict=None, retry=3) -> Tuple[bool, Dict, int]:
    """ Sends GET/POST request to service
    @param string url: the URL to service operator
    @param token: Bearer token
    @param verify: Server side SSL verification
    @param retry: the number of retries
    @param http_body: the dictionary with procedure and list of services
    @returns: True/False, Dict with not empty json body in case Ok/{}, HTTP_CODE/
    IO SSL codes: ssl.SSLErrorNumber.SSL_ERROR_SSL/SSLErrorNumber.SSL_ERROR_EOF
    """
    if(not os.getenv("DEBUG")):
        # Disable warnings about self-signed certificates from requests library
        requests.packages.urllib3.disable_warnings(InsecureRequestWarning)

    if token != "" and FRONT_HTTP_AUTH:
        headers = {"Authorization": f"Bearer {token}"}
    else:
        headers = {}
    if not http_body:
        http_body = {}
    logging.debug(f"REST url: {url}")
    logging.debug(f"REST data: {http_body}")
    logging.debug(f"REST headers: {headers}")

    session = requests.Session()
    retries = Retry(total=retry)
    session.mount('https://', HTTPAdapter(max_retries=retries))
    session.mount('http://', HTTPAdapter(max_retries=retries))

    logging.getLogger("urllib3").setLevel(logging.CRITICAL)

    try:
        if any(http_body):
            resp = session.post(url, json=http_body, timeout=30, headers=headers, verify=verify)
        else:
            resp = session.get(url, timeout=5, headers=headers, verify=verify)
        logging.debug(f"REST response: {resp.json()}")
        return True, resp.json() if resp.json() else {}, resp.status_code # return ANY content with HTTP code

    except requests.exceptions.SSLError as e:
        logging.error("SSL certificate verify failed")
        #TODO in more accurate manner error handling manner
        if "SSLCertVerificationError" in str(e.args): ## SSL Verification fails ; SSLCertVerificationError(1, '[SSL: CERTIFICATE_VERIFY_FAILED] certificate verify failed: unable to get local issuer certificate (_ssl.c:1125)')
            return False, {}, ssl.SSLErrorNumber.SSL_ERROR_SSL.__int__() # - 1
        elif "SSLEOFError" in str(e.args): # SSL connect error, SSL resource is not accessible vi ha-proxy  ; SSLEOFError(8, 'EOF occurred in violation of protocol (_ssl.c:1091)')
            #TODO need a test for this case
            return False, {}, ssl.SSLErrorNumber.SSL_ERROR_EOF.__int__() # - 8
    except requests.exceptions.JSONDecodeError:
        logging.error("Wrong JSON data received")
    except requests.exceptions.RequestException as e:
        logging.error("General request error %s",e.__doc__)
    except Exception as e :
        logging.error("General error %s",e.__doc__)

    return False,{},False


def data_convert_sitecmd_to_dr_mode(site_cmd):
    """ Converts <site_cmd>  into DR mode ["active","standby","disable"]
    """
    if site_cmd == "mntc":
        return "disable"
    elif site_cmd == "return":
        return  "standby"
    else:  # "active","standby" are modes.
        return site_cmd


def sm_process_service(site, service, site_cmd: str, no_wait=False, force=False) -> Tuple[Dict, bool, int]:
    """ Processes the service with specific site cmd """
    global sm_conf

    if site_cmd in ["status","list"]:  # RO operations
        body = {} if service == "site-manager" else {"procedure": "status", "run-services": [service]}
    else:
        body = {"procedure": data_convert_sitecmd_to_dr_mode(site_cmd), "run-services": [service], "no-wait": no_wait, "force": force}

    ret, response, return_code = io_make_http_json_request(sm_conf[site]["url"],
                                                           sm_conf[site]["token"],
                                                           sm_conf[site]["cacert"],
                                                           body)
    return response,True if return_code == HTTPStatus.OK else False, return_code


def sm_poll_service_required_status(site, service, mode, sm_dict) -> Tuple[Dict, bool]:
    """ Polls service status command till desired mode is reached """
    def service_status_polling(site,service, state,error_state=None,timeout=SERVICE_DEFAULT_TIMEOUT,delay=5) -> Tuple[Dict,bool]:
        """   Polls "site-manager status" <service> command till <state> dict returns during <timeout> period with <delay>
        @param state:  expected dict state from site-manager service status command. {"status": ["up"]}
        @param error_state: optional error state which should be processed immediately. {"status": ["failed"]}
        """
        data = {}
        key = list(state.keys())[0]
        value = list(state.values())[0]
        value_error = list(state.values())[0] if error_state else []

        init_time = int(time.time())
        count = 0
        while int(time.time()) <= init_time + int(timeout):
            count += 1

            logging.info(f"Service: {service}. Site: {site}. Polling procedure {key} to be {value} Iteration {count}")
            logging.info(f"Service: {service}. Site: {site}. {int(timeout) - (int(time.time()) - init_time)} seconds left until timeout")

            data, ret, _ = sm_process_service(site, service, "status")

            logging.debug(f"Service: {service}. Site: {site}. Received data: {data}. Return code: {ret}")

            if ret and data["services"][service][key] in value:
                return data, ret
            elif ret and data["services"][service][key] in value_error:
                return data, False
            else:
                time.sleep(delay)
                continue
        return data, False

    data, ret = service_status_polling(site,service,{"status":["done"]},["failed"])
    if not ret:
        return data, ret

    service_status_polling(site,service,{"mode":[mode]})
    if mode == "active":
        data, ret = service_status_polling(site,service,{"healthz":["up"]})
    elif mode == "standby":
        data, ret = service_status_polling(site,service,{"healthz": \
                                                              sm_dict["sites"][site]["services"][service]["allowedStandbyStateList"]})
    else:
        data, ret = service_status_polling(site,service,{"healthz": ["down"]})

    if data["services"][service].get("mode","--") == "--" or \
            data["services"][service].get("status","--") == "--":
        return {"mode": "unknown", "status": "unknown", "healthz": "--"},False
    return data,ret


def print_main_table(sm_dict, services_to_run, sites_name: []):
    """ Method intended to display main section of status table
    @param dict sm_dict: the results of the procedure received from the site-manager
    @param list services_to_run: the list of services that have been processed
    @param list sites_name: list of cluster names
    """
    def make_table(header, sites_name):
        """
        Method for creating the main parts of the table
        """

        pt=PrettyTable()
        pt_field_names=["Service"]

        for sites_item in sites_name:
            pt_field_names.append(f"{sites_item}")

        pt.field_names=pt_field_names
        pt.align["Service"]="l"

        # Additional header
        comment_pt_row = [""]
        separator_pt_row = ["--------------------------"]

        for sites_item in sites_name:
            comment_pt_row.append(header)
            separator_pt_row.append("--------------------------")

        pt.add_row(comment_pt_row)
        pt.add_row(separator_pt_row)

        return pt
    pt = make_table("mode | DR status | healthz", sites_name)
    for service_item in services_to_run:
        service_pt_row = list()
        service_pt_row.append(service_item)
        for sites_item in sites_name:
            if sm_dict['sites'][sites_item]['status'] and sm_dict['sites'][sites_item]['services'][service_item]['status']:
                service_pt_row.append(
                    f"{sm_dict['sites'][sites_item]['services'][service_item]['status']['mode']} / "
                    f"{sm_dict['sites'][sites_item]['services'][service_item]['status']['status']} / "
                    f"{sm_dict['sites'][sites_item]['services'][service_item]['status']['healthz']}")
            else:
                service_pt_row.append("-- / -- / --")
        pt.add_row(service_pt_row)

    print(pt)


def parse_command_line() -> argparse.Namespace:
    """ Main argument parser
    @return:
    """
    parser = argparse.ArgumentParser(description=MAIN_HELP_SECTION,
                                     argument_default=argparse.SUPPRESS,
                                     formatter_class=argparse.RawTextHelpFormatter)

    parser.add_argument('-v', '--verbose', default=False, action='store_true', help='enable the verbosity mode')
    parser.add_argument('-c', '--config', default="", help='define the path to configuration file')
    parser.add_argument('-f', '--force', default=False, action='store_true', help='force apply DR action and ignore healthz')
    parser.add_argument('-k', '--insecure', default=False, action='store_true', help='enable self-signed certificates')
    parser.add_argument('--run-services', default='', help='define the list of services to apply DR action, by default all services participate')
    parser.add_argument('--skip-services',  default='', help='define the list of services what will not participate in DR action')

    subparsers = parser.add_subparsers()

    parser_1 = subparsers.add_parser('move', help='move Active functionality to Standby site')  # DR switchover
    parser_1.add_argument('site', help=SITE_HELP_SECTION)
    parser_1.set_defaults(command='move')

    parser_2 = subparsers.add_parser('stop', help='excludes site from Active-Standby scheme')  # DR failover
    parser_2.add_argument('site', help=SITE_HELP_SECTION)
    parser_2.set_defaults(command='stop')

    parser_3 = subparsers.add_parser('return', help='return stopped Kubernetes cluster to Standby role')
    parser_3.add_argument('site', help=SITE_HELP_SECTION)
    parser_3.set_defaults(command='return')

    parser_4 = subparsers.add_parser('mntc', help='stop Standby kubernetes cluster for maintenance')
    parser_4.add_argument('site', help=SITE_HELP_SECTION)
    parser_4.set_defaults(command='mntc')

    parser_5 = subparsers.add_parser('active', help='set kubernetes cluster services to active mode')
    parser_5.add_argument('site', help=SITE_HELP_SECTION)
    parser_5.set_defaults(command='active')

    parser_6 = subparsers.add_parser('standby', help='set kubernetes cluster services to standby mode')
    parser_6.add_argument('site', help=SITE_HELP_SECTION)
    parser_6.set_defaults(command='standby')

    parser_7 = subparsers.add_parser('list', help='list all services from Active-Standby scheme managed by site-manager with dependencies')
    parser_7.add_argument('site', nargs='?', default="", help=SITE_HELP_SECTION)
    parser_7.set_defaults(command='list')

    parser_8 = subparsers.add_parser('status', help='show current status of clusters and all services')
    parser_8.add_argument('site', nargs='?', default="", help=SITE_HELP_SECTION)  # todo to update help
    parser_8.set_defaults(command='status')

    return parser.parse_args()


if __name__ == "__main__":
    args = parse_command_line()

    if not init_and_check_config(args):
        exit(1)

    ignored_services.extend(skip_services)

    if not main([i for i in run_services if i not in skip_services], args.command,
                args.site if hasattr(args, 'site') else False, args):
        exit(1)

