#!/usr/bin/env python3
import base64
import logging
import os
import time

import yaml
from common import utils
from kubernetes import client, config, watch

# Define kubernetes CR objects
SM_GROUP = os.environ.get("SM_GROUP", "netcracker.com")
SM_PLURAL = os.environ.get("SM_PLURAL", "sitemanagers")
SM_VERSION = os.environ.get("SM_VERSION", "v3")

# Define services default parameters
HTTP_SCHEME = os.environ.get("HTTP_SCHEME", "http://")

# define authentication mode
FRONT_HTTP_AUTH = os.environ.get("FRONT_HTTP_AUTH", False) in (1, True, "Yes", "yes", "True", "true")
BACK_HTTP_AUTH = os.environ.get("BACK_HTTP_AUTH", False) in (1, True, "Yes", "yes", "True", "true")

# Config file to connect to cluster (for dev run)
SM_KUBECONFIG_FILE = os.environ.get("SM_KUBECONFIG_FILE", "")

# Enable debug
SM_DEBUG = os.environ.get("SM_DEBUG", False) in (1, True, "Yes", "yes", "True", "true")

# Config file with specified CRs (for dev run)
SM_CONFIG_FILE = os.environ.get("SM_CONFIG_FILE", "")
if SM_CONFIG_FILE != "":
    try:
        SM_CONFIG = yaml.safe_load(open(SM_CONFIG_FILE))
    except Exception as e:
        logging.fatal("Can not parse configuration file!: \n %s" % str(e))
        exit(1)
else:
    SM_CONFIG = {}

# Token
SM_AUTH_TOKEN = None

# Trust CA cert
SM_CACERT = os.environ.get("SM_CACERT", True)
if SM_CACERT in ("Yes", "yes", "No", "no", "True", "true", "False", "false"):
    SM_CACERT = SM_CACERT in ("Yes", "yes", "True", "true")


def send_post(url, mode, no_wait):
    """ Method to send POST requests to services
    @param string url: the URL to service operator
    @param string mode: is the role of cluster part
    @param bool no_wait: special flag for microservice to show type of replication between of parts of database cluster
    """

    obj = {"mode": mode, "no-wait": no_wait}
    headers = {
        'Content-type': 'application/json',
        'Accept': 'application/json'
    }

    if SM_AUTH_TOKEN:
        headers["Authorization"] = f"Bearer {SM_AUTH_TOKEN}"

    logging.debug(f"REST url: {url}")
    logging.debug(f"REST data: {obj}")

    _, response, _ = utils.io_make_http_json_request(url, http_body=obj, verify=SM_CACERT, token=SM_AUTH_TOKEN, use_auth=BACK_HTTP_AUTH)
    if response:
        return response

    logging.fatal(f"Can't successfully send post request to service endpoint {url}")
    return dict.fromkeys(['fatal'], True)


def get_all_services(sm_dict):
    """
    Method for definition of list of all services in kubernetes cluster managed by site-manager

    :param dict sm_dict: the dictionary generated by get_sitemanagers_dict() and based on CRs from kubernetes clusters
    """

    return list(set([ i for i in sm_dict["services"].keys() ]))


def get_services_to_run(run_services, skip_services, all_services):
    """
    Method for definition of list of services to be processed

    :param list run_services: the list of services that defined by parameter run-services
    :param list skip_services: the list of services that defined by parameter skip-services
    :param list all_services: the list of all services from kubernetes clusters managed by site-manager
    """

    if len(run_services) != 0:
        services_to_run = []
        for item in run_services:
            if item in all_services:
                services_to_run.append(item)
            else:
                logging.fatal(f"Service {item} does not exist in provided kubernetes clusters")
                exit(1)

    elif len(skip_services) != 0:
        services_to_run = all_services.copy()
        for item in skip_services:
            if item in all_services:
                services_to_run.remove(item)
            else:
                logging.fatal(f"Service {item} does not exist in provided kubernetes clusters")
                exit(1)

    else:
        services_to_run = all_services.copy()

    return services_to_run


def get_status(service, *args, **kwargs):
    """
    Method that collects complete information about the state of the service
    @param dict service: service's CR
    """

    output = dict()
    _, status, _ = utils.io_make_http_json_request(service['parameters']["serviceEndpoint"], verify=SM_CACERT, token=SM_AUTH_TOKEN, use_auth=BACK_HTTP_AUTH)
    output["mode"] = status.get("mode", "--")
    output["status"] = status.get("status", "--")
    output["message"] = status.get("message", "")
    if service['parameters'].get("healthzEndpoint", "") != "":
        _, healthz, _ = utils.io_make_http_json_request(service['parameters']["healthzEndpoint"], verify=SM_CACERT, token=SM_AUTH_TOKEN, use_auth=BACK_HTTP_AUTH)
        output["healthz"] = healthz.get("status", "--")
    else:
        output["healthz"] = "--"

    return output


def get_status_with_deps(service, sm_dict, *args, **kwargs):
    """
    Method that collects complete information about the state of the service with dependencies if needed
    @param str service: name of needed service
    @param dict sm_dict: services' CRs
    """
    output = {}
    with_deps = kwargs.get('with_deps', False)

    def collect_services(services, parent_service=None):
        for service_name in services:
            if service_name not in sm_dict['services']:
                logging.error(f"Found not exist dependency: {service_name} in {parent_service} CR")
                raise utils.ProcedureException(output={
                    "message": "Dependency defined in CR doesn't exist",
                    "wrong-service": service_name,
                    "problem-cr": parent_service
            })
            if service_name not in output:
                cr = sm_dict['services'][service_name]
                output[service_name] = get_status(cr, args, kwargs)
                if with_deps:
                    output[service_name]['deps'] = {
                        'before': cr['before'],
                        'after': cr['after']
                    }
                    collect_services(cr['before'], service_name)
                    collect_services(cr['after'], service_name)

    collect_services([service])
    return output


def get_token(api_watch=False):
    """
    Method to get token of sm-auth-sa from kubernetes. Method rewrites global var SM_CLIENT_TOKEN with actual token value

    :param bool api_watch: special flag to define method mode: get token once or follow the token changes.
    """
    global SM_AUTH_TOKEN
    # In testing mode return stab
    if SM_CONFIG.get("testing", {}).get("enabled", False) and \
            SM_CONFIG.get("testing", {}).get("sm_dict", {}) != {}:

        SM_AUTH_TOKEN = SM_CONFIG["testing"].get("token", "123")

        return

    if SM_KUBECONFIG_FILE != "":
        k8s_api_client = config.load_kube_config(config_file=SM_KUBECONFIG_FILE)

        _, current_context = config.list_kube_config_contexts(config_file=SM_KUBECONFIG_FILE)
        namespace = current_context['context'].get('namespace', 'default')

    else:
        k8s_api_client = config.load_incluster_config()
        namespace = open("/var/run/secrets/kubernetes.io/serviceaccount/namespace").read()

    logging.info(f"Current namespace: {namespace}")

    if not api_watch:

        try:
            service_account = client.CoreV1Api(api_client=k8s_api_client).read_namespaced_service_account("sm-auth-sa", namespace)
            secret_name = [s for s in service_account.secrets if 'token' in s.name][0].name
            btoken = client.CoreV1Api(api_client=k8s_api_client).read_namespaced_secret(
                name=secret_name, namespace=namespace).data['token']
            token = base64.b64decode(btoken).decode()

        except Exception as e:
            logging.error("Can not get sm-auth-sa token: \n %s" % str(e))
            os._exit(1)

        SM_AUTH_TOKEN = token

    else:
        counter = 1
        w = watch.Watch()

        while True:
            logging.debug(f"Start watching serviceaccount sm-auth-sa. Iteration {counter}")
            counter += 1

            for event in w.stream(client.CoreV1Api(api_client=k8s_api_client).list_namespaced_service_account,
                                  namespace,
                                  timeout_seconds=30):
                if event['object'].metadata.name == "sm-auth-sa":
                    if event['type'] in ["ADDED", "MODIFIED"]:
                        try:
                            secret_name = [s for s in event['object'].secrets if 'token' in s.name][0].name
                        except: # hit here when secret for appropriate  SA is not ready yet
                            logging.warning("Secret for appropriate SA is not ready yet")
                            continue

                        btoken = client.CoreV1Api(api_client=k8s_api_client).read_namespaced_secret(
                            name=secret_name, namespace=namespace).data['token']
                        token = base64.b64decode(btoken).decode()

                        logging.info(f"Serviceaccount sm-auth-sa was {event['type']}. Token was updated.")

                        SM_AUTH_TOKEN = token

                    if event['type'] == "DELETED":
                        logging.fatal("Serviceaccount sm-auth-sa was deleted. Exit")
                        os._exit(1)
            time.sleep(15)
